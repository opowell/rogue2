Decoded: Rogue (1980) by Toy, Arnold, WichmanDOS version (1983) by Mel Sibony and Jon LaneSource file: MONSTERS.CBeginner friendly, line-by-line code walkthrough by MaiZureMONSTERS.C contains the enemy-centric functions.Original code:https://britzl.github.io/roguearchive/Original code with line numbershttp://www.maizure.org/projects/decoded-rogue/MONSTERS_linenum.txt1     COMMENT2     COMMENT3     COMMENT4     COMMENT5     COMMENT6     BLANK7     Include the game header8     Include the console management header9     BLANK10    COMMENT11    COMMENT12    COMMENT13    BLANK14    Declare a string of level generation monster options (first characters)15    Declare a string of wandering generation monster options16    BLANK17    COMMENT18    COMMENT19    COMMENT20    COMMENT21    COMMENTGENERATE A MONSTER TYPE22    Define randmonster with one argument23    Argument 1 is a flag for wandering monster (as opposed to level monster)24    BLOCK START - randmonster, returns a random monster type25    Declare an index to the monster array26    Declare a pointer to the monster's symbol27    BLANK28    Get a monster from either the wandering array or the level array29    Loop while a valid monster wasn't chosen30    Get a base random number between 0-931    BLANK32    The string index is the dungeon level +/- 533    If the index is less than one34    Set the index to a random number between 1-535    If the index is larger than the string...36    Set the index to a random number between 22-2637    Repeat loop while a proper monster wasn't chosen38    Returns the character of the monster39    BLOCK END - randmonster40    BLANK41    COMMENT42    COMMENT43    COMMENT44    COMMENTINITIALIZE A NEW MONSTER45    Define new_monster with three arguments46    Argument 1 is a pointer to an object that becomes the new monster47    Argument 2 is the type of monster48    Argument 3 is the coordinate of the new monster49    BLOCK START - new_monster, initializes a new monster for the level50    Declare a pointer to a monster prototype51    Declare a level offset52    BLANK53    If the player has found the amulet...54    Then keep the monsters at the level of the amulet level55    Add the monster to the level list of monster56    Set the monster's type57    Match the disguise58    Copy the input coordinate to the new monster's position59    Set the default old character to an unused value60    Get the room of the monster61    Point to the prototype of that monster class62    Copy the monster level data plus the calculated offset63    Fill up the monster's health after rolling for a level offset64    Set the monster's armor capability offset by level difficulty65    Match damage with prototype66    Match strength with prototype67    Match experience with prototype68    Match special monster flags69    The monster is ready to take a turn70    Clear out the monster's inventory71    If the player is wearing a ring of aggression...72    The monster starts off awake and chasing the player73    If the monster is a flytrap74    Monster damage is stored in the the global flytrap damage variable75    If the monster is a Xeroc, it can polymorph so..76    BLOCK START -Switch on 9 or 8 (9 if this is the last level)77    CASE 0: Xeroc looks like a pile of gold78    CASE 1: Xeroc looks like a potion79    CASE 2: Xeroc looks like a scroll80    CASE 3: Xeroc looks like a stairs81    CASE 4: Xeroc looks like a weapon82    CASE 5: Xeroc looks like a armor83    CASE 6: Xeroc looks like a ring84    CASE 7: Xeroc looks like a stick85    CASE 8: Xeroc looks like a amulet86    BLOCK END - Switch on 9 or 887    BLOCK END - new_monster88    BLANK89    COMMENT90    COMMENT91    COMMENTCREATE FLYTRAP DAMAGE92    Define f_restor with no arguments93    BLOCK START - f_restor, set up flytrap damage94    Declare a pointer to the flytrap prototype95    BLANK96    Clear the hit by fungi flag97    Copy the prototype damage string from the global variable98    BLOCK END - f_restor99    BLANK100   COMMENT101   COMMENT102   COMMENT103   COMMENTCALCULATE EXPERIENCE MODIFIER104   Define exp_add with one argument105   Argument 1 is a pointer to a monster106   BLOCK START - exp_add, adds an experience modifier107   Declare the integer return modifier108   BLANK109   If the monster is level 1...110   The base experience is 1/8th of the monster's max hitpoints111   Otherwise112   Base experience is 1/6th113   If the monster is above level 9...114   Multiply the experience by 20!115   Otherwise, if 7, 8, or 9..116   Multiply by 4117   Return the experience modifier118   BLOCK END - exp_add119   BLANK120   COMMENT121   COMMENT122   COMMENT123   COMMENTCREATE WANDERING MONSTER124   Defines wanderer with no arguments125   BLOCK START - wanderer, creates a wandering monster126   Declare an index127   Declare a pointer to a room128   Declare a pointer to a newly created monster129   Declare a coordinate for monster position130   BLANK131   COMMENT132   COMMENT133   COMMENT134   Try to allocate a monster, but if it fails...135   Return failure136   Otherwise loop to place the monster137   Get a random room138   If the random room is the same as the player...139   Skip and try again (can't start near player)140   Choose a random position in the chosen room141   Repeat loop if the monster's coordinates are invalid142   Initialize the new monster143   Check for a test flag (not set)144   If the monster fails to initialize145   Send a debug message146   End check for the test flag147   Check for the wizard mode flag148   If the wizard mode flag is set149   Send a message about the creation of the wanderer150   End check for the wizard mode flag151   Kick off the monster152   BLOCK END - wanderer153   BLANK154   COMMENT155   COMMENT156   COMMENT157   COMMENTWAKE UP A MONSTER158   wake_monster returns a pointer to a monster159   Defines wake_monster with two arguments160   Arguments 1 and two are map positions161   BLOCK START - wake_monster, sets off a monster chasing the player162   Declare a pointer to the monster163   Declare a pointer to a room164   Declare a character for a monster type165   Declare a distance variable166   BLANK167   If there is no monster at the input coordinates...168   Return failure169   Get the monster's type170   COMMENT171   COMMENT172   COMMENT173   If the player is running, monster is mean and not held and on a 66% roll174   If the player isn't stealthy...175   BLOCK START - Target player176   The monster targets the player177   The monster is now running178   BLOCK END - Target player179   If the monster is a Medua and the player isn't blind and player saw it..180   And the monster hasn't been interrupt and is running...181   BLOCK START - Medusa special power182   Get the player's room pointer183   Get the distance to the player184   If the room is valid and isn't dark or is within the lamp distance...185   Player has seen the monster186   If the player fails a magic roll187   And the player is confused188   Exntend the confusion by 0-40 turns189   Otherwise the player is confused190   Start player confusion between 0-40 turns191   Set the palyer confusion flag192   Send a message about confusion193   End check for player seeing Medusa194   End check for Medusa195   BLOCK END - Medusa special power196   COMMENT197   COMMENT198   COMMENT199   If the monster is greedy (guarding gold) and isn't running200   Set the monster to running201   If the room has gold202   The monster is running to the gold203   Otherwise...204   The monster is running after the player205   End check for greedy monsters206   Return the monster pointer207   BLOCK END - wake_monster208   BLANK209   COMMENT210   COMMENT211   COMMENT212   COMMENTCREATE MONSTER INVENTORY213   Defines give_pack with one argument214   Argument 1 is a pointer to a monster215   BLOCK START - give_pack, creates inventory for a monster216   COMMENT217   COMMENT218   COMMENT219   If there is space and if we successfully roll against monster type...220   Add a random item to the monster's inventory221   BLOCK END - give_pack222   BLANK223   COMMENT224   COMMENT225   COMMENT226   COMMENT227   BLANKGET A RANDOM MONSTER TYPE228   Defines pick_mons with no arguments229   BLOCK START - pick_mons, chooses a monster as a vorpal type230   Declare a pointer to the end of level generation monster string231   BLANK232   Walk backwards across the string until a roll success233   Repeat walk as needed234   If the we walk the entire string without success235   Generate an anti-Medusa weapon236   Return the monster237   BLOCK END - pick_mons238   BLANK239   BLANK240   COMMENT241   COMMENT242   COMMENT243   COMMENT244   COMMENT245   BLANKCHECK FOR MONSTER AT A POSITION246   moat returns a pointer to a monster247   Defines moat with two argments248   Arguments 1 and 2 are coordiantes249   BLOCK START - moat, returns a monster at an input position250   Declares a pointer to a monster251   BLANK252   Loop through all the monsters253   If the monster's position matches the lookup coordinates254   Return the pointer to the monster255   Return NULL if no match256   BLOCK END - moat257   EOF