Decoded: Rogue (1980) by Toy, Arnold, WichmanDOS version (1983) by Mel Sibony and Jon LaneSource file: MAZE.CBeginner friendly, line-by-line code walkthrough by MaiZureMAZE.C provides functions for drawing mazes. There may be an issue with thisfile - some code seems dead or in an incomplete/transitionary stateOriginal code:https://britzl.github.io/roguearchive/Original code with line numbershttp://www.maizure.org/projects/decoded-rogue/MAZE_linenum.txt1     COMMENT2     COMMENT3     COMMENT4     COMMENT5     COMMENT6     COMMENT7     BLANK8     Include the game header9     Include the console management header10    Bring in the height of the map defined in MACH_DEP.C (22 or 23 lines)11    BLANK12    Define a limit to the size of the logical maze frontier to 100 nodes13    BLANK14    Define a macro for FRONTIER to be the character 'F'15    Define a macro for NOTHING to be a space16    BLANK17    Declare compilation unit integers for various maze metric temporaries18    Declare compilations unit intergers for boundary sizes19    Declare pointers to frontier positions20    BLANKDRAW MAZE21    Define draw maze with 1 argument22    Argument 1 is a pointer to the room area that the maze is drawn over23    BLOCK START - draw_maze, draws a maze by manipulating map data in place24    Declare temporary integers for room positions25    Declare two arrays for frontier values, one for x and one for y26    Declare a counter for passages27    Declare a coordinate pair used for map positions28    BLANK29    Point the y frontier array to the base of the local array y30    Point the x frontier array to the base of the local array x31    Initialize the max values to 032    Set the top y of the maze to the top of the room33    If the top of the maze is 0...34    Then boost it to 1...don't start on the exact top edge35    Set the top x of maze to the left size of the room36    COMMENT37    COMMENT38    COMMENT39    COMMENT40    Set our working y position to the top (not random as the comment claims)41    Set our working x position to the left (not random)42    Set the initial position to passages43    Add neighboring positions to the frontier44    COMMENT45    COMMENT46    COMMENT47    COMMENT48    While there is a frontier49    BLOCK START - Add from frontier50    Connect a random frontier element to the maze51    Calculate the new frontier since the maze just changed52    BLOCK END - Add from frontier53    COMMENT54    COMMENT55    COMMENT56    COMMENT57    Set the room's max.x based on the passages drawn so far. Note that this      variable was the largest possible room size prior to this statement58    Set the room's max.y based on the passages drawn so far59    Being a loop60    Define a coordinate array with four elements61    The first element is a coordinate offset for up62    The first element is a coordinate offset for right63    The first element is a coordinate offset for down64    The first element is a coordinate offset for left65    End of coordinate array definition66    Declare a coordinate pointer67    Declare an integer68    BLANK69    Choose a random point in the room and store it in spos70    Loop through the array 4 times..71    Offset the action coordinates based on the above array.72    If the new position is not off the map and is a passage...73    Increment the page count (order is 1, 3, 7, 15, ...)74    End offset loop75    Redo the loop and set each set to a valid passage76    Set the final point as a valid passage77    BLOCK END - draw_maze78    BLANKNEW FRONTIER Frontier grows in all cardinal directions starting two points away from the      input location79    Define new_frontier with two arguments80    Arguments are an x and y map point81    BLOCK START - new_frontier, adds cardinal points to the frontier82    Attempts to add the map point two spaces above the input83    Attempts to add the map point two spaces below the input84    Attempts to add the map point two spaces left of the input85    Attempts to add the map point two spaces right of the input86    BLOCK END - new_frontier87    BLANKADD FRONTIERA 'frontier' is a point that is a candidate to become a part of the maze buthasn't been chosen yet. It borders at least one actual maze passage.88    Defines add_frnt with with arguments89    Both arguments form a coordinate within the map90    BLOCK START - add_frnt, adds a point to the potential maze frontier91    If debug mode is enabled (it's not)...92    And if we already have the maximum number of frontier candidates...93    Print an error message94    End check for debug mode95    If the point is in the maze and hasn't been assigned yet...96    BLOCK START - add point to the frontier97    Set the point as a frontier space98    Add that point's x coordinate to the frontier tracking array99    Add y coordinate to the fontier array and increment the array counter100   BLOCK END - add point to the frontier101   BLOCK END - add_frnt102   BLANK103   COMMENT104   COMMENT105   COMMENTCONNECT FRONTIER106   Define con_frnt wih no arguments107   BLOCK START - con_frnt, connects a frontier point with the maze108   Declare some local variables for the calculations109   Declare an integer array to hold four possible connection directions110   Declare and initialize count to zero. Also coordinate points111   BLANK112   BLANK113   COMMENT114   COMMENT115   COMMENT116   Choose a random index in to the frontier array117   Grab the y position of the chosen frontier118   Grab the x position of the chosen frontier119   Copy the last frontier y point in the array to the now-used point120   Copy the last x to the used x position. Decrement the array size.121   BLANK122   COMMENT123   COMMENT124   COMMENT125   If the map point two above the frontier is a valid passage...126   Add that choice to the possible selections and increment the counter127   If the map point two below the frontier is a valid passage...128   Add that choice to the possible selections and increment the counter129   If the map point two to the left of the frontier is a valid passage...130   Add that choice to the possible selections and increment the counter131   If the map point two to the right of the frontier is a valid passage...132   Add that choice to the possible selections and increment the counter133   COMMENT134   COMMENT135   COMMENT136   COMMENT137   Randomize one of the valid directions. At least one is always valid138   Make the frontier point a valid part of the maze139   SWITCH on the chosen direction140   BLOCK START - Switch on a direction141   CASE up: set the change in y coordinate142   CASE down: set the change in y coordinate143   CASE left: set the change in x coordinate144   CASE right: set the change in x coordinate145   BLOCK END - Switch on a direction146   Set the current y to the calculated delta coordinate147   Set the current x to the calculated delta coordinate148   Check that the chosen direction is part of the maze room...149   And dig out the passage, connecting it to the main maze150   BLOCK END - con_frnt151   BLANKFIND MAZE VALUE152   Define maze_at with two arguments, an x/y coordinate pair153   BLOCK START - maze_at, checks a point and returns true if it's a maze154   If the pair is within the room and it's also a valid passage...155   Return true156   Otherwise...157   Return false158   BLOCK END - maze_at159   BLANKSET MAZE PASSAGE160   Define splat with two arguments, an x and y coordinate161   BLOCK START - splat, sets input point as a maze passage.162   Set the map point as a passage163   Update the point flags to be164   If the input x is the largest in use so far...165   Update the max x tracking variable166   If the input y is the largest in use so far...167   Update the max y tracking variable168   BLOCK END - splat169   BLANK170   Set MAXY to be one third of the height of the screen from the top y171   Set MAXX to be one third of the width of the screen from the top x172   BLANKCHECK MAZE BOUNDARIES173   Define inrange with two arguments174   Both arguments are a coordinate to check175   BLOCK START - inrange, returns true if the input is within the room176   Return a typical four corners check on the x, y pair and the boundary177   BLOCK END - inrange178   EOFÿ