1 ; :ts=82 ;Copyright (C) 1983 by Manx Software Systems3 dataseg	segment	para public 'data'4 	extrn	$MEMRY:word5 	extrn	_mbot_:word, sbot:word6 	extrn	errno_:word7 dataseg	ends8 codeseg	segment	para public 'code'9 	assume	cs:codeseg,ds:dataseg,es:dataseg,ss:dataseg10 ;11 ; sbrk(size): return address of current top & bump by size bytes12 ;13 	public sbrk_14 sbrk_	proc	near15 	mov	bx,sp16 	push	di17 	mov	ax,2[bx]18 	mov	di,$MEMRY19 	add	ax,di20 	push	ax21 	call	brk_22 	pop	cx23 	jnz	brk_error24 	mov	ax,di		;return original value of the break25 brk_error:26 	pop	di27 	test	ax,ax		;set flags for C28 	ret29 ;30 ; brk(addr):	set current top address to addr31 ;		returns 0 if ok, -1 if error32 ;33 	public	brk_34 brk_:35 	mov	bx,sp36 	mov	ax,2[bx]37 	cmp	ax,sbot			;check for stack/heap overflow38 	jae	brk_ov39 	cmp	ax,bx			;double check with sp for saftey40 	jae	brk_ov41 ;	cmp	ax,_mbot_		; ** DISABLED FOR ROGUE42 ;	jb	brk_ov			; ** DISABLED FOR ROGUE43 	mov	$MEMRY,ax	;new value is good so save it away44 	sub	ax,ax45 	ret46 ; invalid request47 brk_ov:48 	mov	errno_,-449 	mov	ax,-150 	test	ax,ax51 	ret52 ;53 ; rsvstk(size):		set saftey margin for stack54 ;			this will make sure that at least size55 ;			bytes of stack below the current level remain.56 ;57 rsvstk_:58 	mov	bx,sp59 	sub	bx,2[bx]60 	mov	sbot,bx61 	ret62 sbrk_	endp63 codeseg	ends64 	end65 ÿ