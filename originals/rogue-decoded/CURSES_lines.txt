Decoded: Rogue (1980) by Toy, Arnold, WichmanDOS version (1983) by Mel Sibony and Jon LaneSource file: CURSES.CBeginner friendly, line-by-line code walkthrough by MaiZureCURSES.C provides console management routines for I/O control. This seems likea custom implementation ported to DOS specifically for RogueOriginal code:https://britzl.github.io/roguearchive/Original code with line numbershttp://www.maizure.org/projects/decoded-rogue/CURSES_linenum.txt1     COMMENT2     COMMENT3     COMMENT4     Includes the game header5     Includes the curses header6     BLANK7     Imports the memory allocation call linked from SBRK.ASM8     COMMENT9     COMMENT10    COMMENT11    Initialize screen dimension globals for text mode - 25x8012    Declare flag signalling if screen state has been saved for later13    Declare a flag for the cursor state - on or off14    Declare an integer to hold the character display mode (fore/back color)15    Declare a global holding the previously posted memory page16    Declare a flag enabled if we're checking monitor retrace state17    BLANK18    Initializes the screen data segment, 0xB800 is the base memory page for      CGA/EGA/VGA. Note that the original Monochrome starts at 0xB00019    Declare an integer to hold the window data segment20    BLANK21    Declare a pointer to the saved screen to dump to or restore from22    Declare the screen mode23    Declare the tab size24    Declare the current memory page number25    BLANK26    Define a macro for the maximum number of character format attributes27    Initialize an array of character attributes for color monitors28    A color attribute (this ordering is mostly unique -- never standardized)29    A color attribute30    A color attribute31    A color attribute32    A color attribute33    A color attribute34    A color attribute35    A color attribute36    A color attribute37    A color attribute38    A color attribute39    A color attribute40    A color attribute41    A color attribute42    A color attribute43    A color attribute44    A color attribute45    Blank (also black)46    End of color monitor attributes47    BLANK48    Initialize attribute array for monochrome monitors49    A monochrome attribute50    The same monochrome attribute51    Look Monochrome only has 1 color right?52    But we still need compatability with the color code right?53    Guess we have to plug this array with the exact same attribute54    Over55    and Over56    and Over57    and Over58    ...59    Yup, still just the same color60    zzzzz61    Oh look, a different attribute!62    And we're back to the same old attribute63    A third attribute!64    Old faithful again65    The same third attribute.66    Black -- and end of out monochrome attributes67    End of monochrome attribute data68    BLANK69    Declare a generic pointer to one of the attribute tables70    BLANK71    Declare globals to cache the cursor position...avoids interrupts72    Declare a global array for a screen row of data73    BLANK74    Declares an array of characters used for drawing double border boxes75    A set of ASCII characters from code page 43776    End of character array77    BLANK78    Declares an array of characters used for drawing single border boxes79    A set of ASCII characters from code page 43780    End of character array81    BLANK82    Declares an array of characters used for drawing thick border boxes83    A set of ASCII characters from code page 43784    End of character array85    BLANK86    Declares an array of characters used for blank boxes...black border?87    A set of ASCII characters from code page 43788    End of character array89    BLANK90    COMMENT91    COMMENT92    COMMENTCLEAR THE SCREEN93    Defines clear with no argument94    BLOCK START - clear, clears the screen95    If we're currently processing the saved screen state buffer...96    Copy the saved screen data to the buffer97    Otherwise this is a basic clear screen98    Set entire screen memory page to 099    BLOCK END - 100   BLANK101   BLANK102   COMMENT103   COMMENT104   COMMENTENABLE/DISABLE BLINKING CURSOR105   Define cursor with one argument106   Argument 1 is the flag for the desired state (on or off)107   BLOCK START - cursor, turns cursor on and off108   Declare a variable for the old cursor state109   Declare an unused variable (dead code)110   BLANK111   BLANK112   If we're attempting to turn on a cursor that's already on...113   Just return, don't bother wasting interrupt time114   Set the old state to the current state115   Update the current state to the requested state116   BLANK117   Set the AH = 0x01 (changing cursor state)118   If we're turning on the cursor...119   BLOCK START - Turn on cursor120   In color mode, set cursor to CX=0x0607 (blinking at ~half size)121   Invoke the actual interrupt - BIOS 0x10122   Move the cursor to the most recent position123   BLOCK END - Turn on cursor124   Otherwise we're turning off the cursor125   BLOCK START - Turn off cursor126   Set CX = 0xf00 (invisible on EGA/VGA)127   Invoke BIOS interrupt 0x10 with new AX/CX values128   BLOCK END - Turn off cursor129   Return the previous state of the cursor (easy to save and restore state)130   BLOCK END - cursor131   BLANK132   BLANK133   COMMENT134   COMMENT135   COMMENTGET CURSOR POSITION FROM CACHE136   Define getrc with two arguments137   Arguments are pointers to the the cached row and column values138   BLOCK START - getrc, updates the cursor position pointers to the cache139   Set the row pointer to our global cursor row cache variable140   Set the column pointer to our global cursor column cache variable141   BLOCK END - getrc142   BLANKGET CURSOR POSITION FROM BIOS143   Defines real_rc with three arguments144   Argument 1 is memory page number, 2 and 3 are pointers to position vars145   BLOCK START - real_rc146   COMMENT147   COMMENT148   COMMENT149   Prepare to read cursor position (AH = 0x03)150   Put the memory page number in to BH by byte shifting in to BX151   BLANK152   Invoke the BIOS interrupt (0x10) - Position in DX, size in CX (ignored)153   BLANK154   Point the row to the value in DH (have to right shift a byte)155   Point the column to the value in DL (mask only the lower byte)156   BLOCK END - real_rc157   BLANK158   COMMENT159   COMMENT160   COMMENTCLEAR A SCREEN ROW161   Declare clrtoeol with no arguments162   BLOCK START - clrtoeol, clear a row on the screen163   Declare row and column variables164   BLANK165   If we're not even looking at the current screen...166   Don't bother167   Otherwise, get the current cursor position168   Clear the whole row169   BLOCK END - cleartoeol170   BLANKMOVE CURSOR TO POSITION AND PRINT A STRING171   Declare mvaddstr with three arguments172   Arguments 1 and 2 are row and column positions173   Argument 3 is a pointer to the string174   BLOCK START - mvaddstr, prints a string starting at a position175   Move the cursor to the position176   Print the string177   BLOCK END - mvaddstr178   BLANKMOVE CURSOR TO POSITION AND PRINT A CHARACTER179   Defines mvaddch with three arguments180   Arguments 1 and 2 are row and column positions181   Argument 3 is the character to print182   BLOCK START - mvaddch, prints a character at a position183   Move cursor to position184   Print the character185   BLOCK END - mvaddch186   BLANKMOVE CURSOR TO POSITION AND READ THE CURRENT CHARACTER187   Defines mvinch with 2 arguments188   Arguments 1 and 2 are the cursor position to read189   BLOCK START - mvinch, Returns a character at a position190   Move cursor to position191   Return the first byte at that position (ASCII code)192   BLOCK END - mvinch193   BLANK194   COMMENT195   COMMENT196   COMMENT197   COMMENT198   BLANKPRINT A CHARACTER TO CURRENT POSITION (GAME-BASED, NOT GENERAL PURPOSE)199   Declares addch with one argument200   Argument 1 is the character to print201   BLOCK START - addch, prints a character to the current position202   Declare row and column position integers203   Declare upated row and column integers204   Declare a character to hold the old attribute205   BLANK206   Set the old attribute to the current global attribute setting207   BLANK208   If we're using a color screen...209   BLOCK START - color printing, we have to update attr with pretty stuff210   COMMENT211   If we're printing the regular base color used in rooms...212   SWITCH on the room object to print213   BLOCK START - Switch on character to update color214   CASE character is a door215   CASE character is a vertical wall216   CASE character is a horizontal wall217   CASE character is an upper-left corner218   CASE character is an upper-right corner219   CASE character is a lower-left corner220   CASE character is a lower-right corner221   Change the current color to brown222   Break out of color changes223   CASE character is the floor224   Change the current color to light green225   Break out of color changes226   CASE character is the stairs227   Change the current color to black text, green background228   Break out of color changes229   CASE character is a visible trap230   Change the current color to magenta231   Break out of color changes232   CASE character is gold233   CASE character is the player avatar234   Change the current color to yellow235   Break out of color changes236   CASE character is a potion237   CASE character is a scroll238   CASE character is a wand/staff239   CASE character is armor240   CASE character is an amulet241   CASE character is a ring242   CASE character is a weapon243   Change the current color to light blue244   Break out of color changes245   CASE character is food246   Change the current color to red247   Break out of color changes248   BLOCK START - Switch on character to update color249   COMMENT250   Otherwise, check if the color is the default passage color251   SWITCH on the passage object to rpint252   BLOCK START - Switch on character to update color253   CASE character is food254   Change the current color to red background, black text255   Break out of color changes256   CASE character is gold257   CASE character is the player258   Change the current color to yellow text, white background259   Break out of color changes260   CASE character is a potion261   CASE character is a scroll262   CASE character is a wand/staff263   CASE character is armor264   CASE character is an amulet265   CASE character is a ring266   CASE character is a weapon267   Change the current color to blue background, black text268   Break out of color changes269   BLOCK END - Switch on character to update color270   For all other color cases...271   Stairs are black text on green background272   End check for color screens, the rest is color and mono handling273   BLANK274   Get the current row and column275   If the current character is a newline...276   And if we're at the end of a page...277   Scroll the screen up one line278   Move the cursor to the last screen line279   Otherwise, we're in the middle of the screen somewhere so...280   Move the cursor down one line281   Set the cursor attribute to the old attribute282   Return the current column283   End check for newline character284   Print the character that is properly position with the correct color285   Move the cursor to the right286   Save the color attribute we just used287   COMMENT288   COMMENT289   COMMENT290   Return current row291   BLOCK END - addch292   BLANKPRINT A STRING TO THE SCREEN293   Defines addstr with one argument294   Argument 1 is a pointer to the string295   BLOCK START - addstr, prints a string to the screen296   While there is a valid character...297   Print character to the screen and increment pointer to next character298   BLOCK END - addstr299   BLANKCHANGE COLOR300   Define set_attr with one argument301   Argument 1 is the input attribute index or a raw attribute302   BLOCK START - set_attr303   If the input attribute is a valid index...304   Set the current attribute from the table305   Otherwise...306   Assume that the input is the attribute, not an index307   BLOCK END - set_attr308   BLANKGENERATE ERROR (NOT USED)309   Defines error with seven arguments310   Argument 1 is the error row on the screen311   Argument 2 is the error message312   Arguments 3 to 7 are the message arguments313   BLOCK START - error, prints an error (not used)314   Declares local row and columns315   BLANK316   Get the current row and column317   Move the cursor to the beginning of the error line318   Clear the line319   Print the error message320   Return the cursor to the current position321   BLOCK END - error322   BLANK323   COMMENT324   COMMENT325   COMMENT326   COMMENT327   BLANKSET CURSOR (DEAD CODE)328   Defines set_cursor with no arguments329   BLOCK START - set_cursor, dead code330   COMMENT331   COMMENT332   COMMENT333   COMMENT334   COMMENT335   BLOCK END - set_cursor336   BLANK337   COMMENT338   COMMENT339   COMMENT340   COMMENT341   COMMENT342   COMMENTINITIALIZE GAME WINDOW343   Defines winit with one argument344   Argument 1 is unused, but was probably the default drive letter345   BLOCK START - winit, initializes the game window346   Declare an iterator and a counter347   Import the current datasegment348   BLANK349   COMMENT350   COMMENT351   COMMENT352   Set AH to 0xF to get the current video mode and active memory page353   Invoke the interrupt354   Save the memory page number from the result in BX355   Get the screen type356   COMMENT357   COMMENT358   COMMENT359   COMMENT360   COMMENT361   Set the number of rows on the screen to 25362   Set the number of columns on the screen to 80363   Set the video memory base to 0xB800364   Set the current color mode to monochrome365   BLANK366   BLOCK START - SWITCH on the screen type367   COMMENT368   COMMENT369   COMMENT370   CASE type 1 (color, 40x25 text)371   Set attribute table to color372   CASE type 0 (monochrome, 40x25 text)373   Set columns to 40374   Break from check for video type375   BLANK376   COMMENT377   COMMENT378   COMMENT379   CASE type 3 (color, 80x25 text)380   Set the attribute table to color381   CASE type 2 (monochrome, 80x25 text)382   Break - this is the default init from above383   CASE type 7 (monochrome, 80x25)384   This is a true Monochrome (tm) device - memory base is at 0xB000385   Disable retrace check386   Break from check for video type387   COMMENT388   COMMENT389   COMMENT390   COMMENT391   COMMENT392   COMMENT393   COMMENT394   COMMENT395   COMMENT396   CASE any other screen mode..397   Move the cursor to the bottom left398   Print an error message and fail out of program399   End select for video mode400   COMMENT401   COMMENT402   COMMENT403   Get the current cursor position404   Initialize backup video buffer with 4kb but if it fails...405   The window segment is invalid406   Point the backup buffer to the known good flags segment407   But if we're using a monochrome monitor...408   Fail out due to lack of memory409   Otherwise, memory allocation was successful so..410   Nibble align the value...why?411   Grab buffer segment base address by offsetting 12 bits in to the dataseg412   End memory allocation for window save buffer413   Loop through each row414   Count the byte offset for each row and save415   Allocate (and leak..?) 2 bytes. Possibly for alignment guarantee416   Change to the 4th memory page417   If we weren't already on the 4th page...418   Clear the screen (memory)419   Move the cursor to the current position420   If this is a PC Jr..421   Disable retrace check422   BLOCK END - winit423   BLANKFORCE COLOR TO BLACK & WHITE424 425   BLOCK START - forcebw, sets mode to black and white426   Points the attribute table to the monochrome table427   BLOCK END - forcebw428   BLANK429   COMMENT430   COMMENT431   COMMENT432   COMMENT433   COMMENTSAVE THE CURRENT SCREEN STATE434   Define wdump with no arguments435   BLOCK START - wdump, outputs the screen state to backup buffer436   If memory allocation failed, push level flags out to the screen437   In any case, read the screen buffer and save it to savewin438   Screen is now saved439   BLOCK END - wdump440   BLANKSAVE THE CURRENT SCREEN FLAGS441   Defines sav_win with no arguments442   BLOCK START - sav_win, saves the level flags to video memory443   Check if we're on Plan B of backup buffer444   Send the current level flags out to video memory base page445   Return pointer used446   BLOCK END - sav_win447   BLANKRESTORE THE LEVEL FLAGS448   Defines res_win with no arguments449   BLOCK START - res_win, restores the level flags stored in video memory450   Checks if backup memory allocation originally failed...451   If so, we need to bring the flags back via DMA452   BLOCK END - res_win453   BLANK454   COMMENT455   COMMENT456   COMMENT457   COMMENTRESTORE THE SAVED SCREEN STATE458   Defines wrestor with no arguments459   BLOCK START - wrestor, loads a save console screen from memory460   Send stored screen data back to video memory461   Get flags back stored in page 0 of video memory462   Screen is no longer saved463   BLOCK END - wrestor464   BLANK465   COMMENT466   COMMENT467   COMMENT468   COMMENTSHUT DOWN THE SCREEN469   Defines wclose with no arguments470   BLOCK START - wclose, closes the output window471   BLANK472   COMMENT473   COMMENT474   COMMENT475   If we have a valid video mode...476   Turn the cursor on477   If we've changed pages for some reason478   Move back to the desired page479   BLOCK END - wclose480   BLANK481   COMMENT482   COMMENT483   COMMENT484   BLANKDRAW A GENERAL PURPOSE BOX485   Define box with four arguments, the 4 corner positions of the box486   BLOCK START - box, draws a box on the screen using input coordinates487   Draw a styled box with double borders at the given position488   BLOCK END - box489   BLANK490   COMMENT491   COMMENT492   COMMENT493   COMMENT494   BLANKDRAW A STYLIZED BOX495   Declares vbox with five arguments496   Argument 1 is the character set structure to draw the box with497   Arguments 2-5 are the 4 corners of the box498   BLOCK START - vbox, draws an ASCII box on the screen 499   Declare an iterator and a state flag500   Declare two integers for row and column position501   BLANK502   Turn off the cursor and save its previous state503   Get the starting cursor position504   BLANK505   COMMENT506   COMMENT507   COMMENT508   Move the cursor to the upper left of the box (+1 to draw corners last)509   Draw the top box horizonal510   Move cursor to bottom left +1511   Draw the bottom box horizonal512   COMMENT513   COMMENT514   COMMENT515   Loop from the top of the box to the bottom516   Draw the left verical wall517   Draw the right vertical wall518   Repeat loop519   COMMENT520   COMMENT521   COMMENT522   Draw upper left corner523   Draw upper right corner524   Draw lower left corner525   Draw lower right corner526   BLANK527   Move the cursor to the original position528   Restore the cursor to its previous state529   BLOCK END - vbox530   BLANK531   COMMENT532   COMMENT533   COMMENTCENTER TEXT ON THE SCREEN534   Define center with two arguments535   Argument 1 is the row to draw the string536   Argument 2 is the string to draw537   BLOCK START - center, centers a string on the screen538   Draw the string starting at colums, minus string length divided by 2539   BLOCK END - center540   BLANK541   BLANK542   COMMENT543   COMMENT544   COMMENTPRINT FORMATTED MESSAGE545   Define printw with nine arguments546   Argument 1 is a message to output547   Arguments 2-9 are formatted argumented548   BLOCK START - printw, prints an (almost) variadic string to the screen549   Declare a temporary buffer of 132 bytes550   Output the formatting string to the global print buffer551   Print the print buffer552   BLOCK END - printw553   BLANKSCROLL ROW UP554   Declare scroll_up with three arguments555   Arguments are the start/end pointers on the row and the number of lines556   BLOCK START - scroll_up, scrolls a screen region up 1 line557   Set up for BIOS INT 0x10 call by putting AH=0x6, AL = scroll distance558   Set up BX for the attributes of new blank lines559   Left bound to CX560   Right bound to DX561   Invoke software interrupt562   Move the cursor to the end of the changed row563   BLOCK END - scroll_upSCROLL ROW DOWN564   Declare scroll down with three arguments565   Arguments are the start/end pointers on the row and the number of lines566   BLOCK START - scroll_dn, scrolls a screen region down 1 line567   Set up for BIOS INT 0x10 call by putting AH=0x7, AL = scroll distance568   Set up BX for the attributes of new blank lines569   Left row position in CX570   Right row position in DX571   Invoke INT 0x10572   Move the cursor to the start of the changed row573   BLOCK END - scroll_dn574   BLANKSCROLL WHOLE SCREEN UP 575   Define scroll with no arguments576   BLOCK START - scroll, scrolls the screen up one line577   Scroll the entire screen up 1 line578   BLOCK END - scroll579   BLANK580   BLANK581   BLANK582   COMMENT583   COMMENT584   COMMENT585   COMMENT586   COMMENTCLEAR A REGION OF THE SCREEN587   Define blot_out with four arguments (the four corners)588   BLOCK START - blot_out, clear a screen region589   Set up AX like a scroll up until it's off the screen590   New rows have attribute 0x07591   Set up left side of the row change592   Set up right side593   Invoke interrupt 0x10594   Move the cursor to the upper left position of the cleared box595   BLOCK END - blot_out596   BLANKREPEATEDLY PRINT A CHARACTER597   Define repchr with two arguments598   Argument 1 is the character two print. Arg 2 is the number of repeats599   BLOCK START - repchr, repeats a character600   While there is still work to do...601   Print character602   Advance cursor column 1 space603   End print loop604   BLOCK END - repchr605   BLANK606   COMMENT607   COMMENT608   COMMENTPATCH SCREEN AFTER CTRL-BREAK609   Define fixup with no arguments610   BLOCK START - fixup, clear a screen column611   Clear the region around the cursor612   BLOCK END - fixup613   BLANK614   COMMENT615   COMMENT616   COMMENT617   BLANKANIMATED CLEAR SCREEN618   Define implode with no arguments619   BLOCK START - implode, clear screen animation620   Define a lot of helpers, including a column incrementor621   BLANK622   Set an invariant to be 21 or 22, depending on screen size623   COMMENT624   COMMENT625   COMMENT626   If there is nothing on the screen...627   Don't bother - clear memory628   Exit function629   End check for empty screen630   Set a delay factor for visible drawing. Monochrome is FAST so big delay631   Loop across various positions through the screen in patchwork fashion632   Draw single boxes of shrinking sizes633   Start a delay loop634   Repeat delay loop635   Loop across the current row636   Draw spaces from the left637   Draw spaces from the right638   End row loop639   Draw another box640   Repeat this mess until the screen has finished drawing641   BLOCK END - implode642   BLANK643   COMMENT644   COMMENT645   COMMENT646   COMMENTSCREEN SCROLL OUT ANIMATION647   drop_curtain returns address of the old data segment648   Define drop_curtain with no arguments649   BLOCK START - drop_curtain, slide out screen updating animation650   Declare local integers for row/column position, an interator and delay651   BLANK652   If we're not looking at an active screen...653   Then nothing to fade out - return654   Store the screen segment655   Save the screen data in to the backup buffer656   Turn off the cursor657   Set a delay - high if monocrhome since it's fast658   Set the foreground color to green659   Draw a single-border box around the whole screen660   Set color to yellow661   Loop through all rows662   Move the cursor to the start of the row663   Print the code page 437 character for dotted-box across the row664   Delay for the desired cycles665   Repeat delay666   End drawing across rows667   Reset the screen data segment to the saved screen668   Move the cursor to the start669   Undo character highlighting670   BLOCK END - drop_curtain671   BLANKSCREEN SCROLL IN ANIMATION672   Define raise_curtain with no arguments673   BLOCK START - raise_curtain, slide in screen updating effect674   Declare iterators, a position variable, and a delay675   BLANK676   If we're looking at the saved screen buffer (nothing on screen)677   Then there's nothing to do - return678   Restore the old data segment679   Set a delay so we can see animations680   Loop through each row681   Output the saved window segment back to the screen682   Delay on each row683   Repeat delay684   End loop through each row685   BLOCK END - raise_curtain686   BLANKSWAP VIDEO MEMORY PAGES687   Define switch_page with one argument - the memory page number688   BLOCK START - switch_page, swaps video memory page689   Ddeclare an integer for the page size690   BLANK691   If the screen is monochrome692   Start on page 0693   Return694   End check for monochrome695   If the screen is small, only 40 characters wide696   Then use page sizes of 2kb697   Otherwise...698   Page size is 4kb699   Set AH to 0x05 - setting active page in video memory700   Invoke the interrupt701   Set the screen data segment is at base 0xB800 plus the page offset702   Set the page number global to the input page number703   BLOCK END - switch_page704   BLANKGET VIDEO MODE FROM BIOS705   Defines get_mode with one unused argument706   BLOCK START - get_mode, returns the video mode using BIOS707   Bring in register structure708   BLANK709   Assign AH to 0x0F710   Invoke BIOS Interrupt 0x10 to get the current video mode711   Return video mode to caller712   BLOCK END - get_mode713   BLANKGENERIC BIOS CALLApparently used for video...but you can insert ANY INT 10 call in here...hmm714   Define video mode with argument 1 as the desired video mode715   BLOCK START - video_mode, sets the video mode716   Bring in the register structure717   BLANK718   Assign AX to the video mode719   Invoke BIOS Interrupt 0x10 to change video modes720   Return the resulting video mode flag721   BLOCK END - video_mode722   EOF