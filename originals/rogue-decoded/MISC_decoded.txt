Decoded: Rogue (1980) by Toy, Arnold, WichmanDOS version (1983) by Mel Sibony and Jon LaneSource file: MISC.CBeginner friendly, line-by-line code walkthrough by MaiZureMISC.C is the giant filing cabinet of support functions that don't fitanywhere else.Original code:https://britzl.github.io/roguearchive/Original code with line numbershttp://www.maizure.org/projects/decoded-rogue/MISC_linenum.txt1     COMMENT2     COMMENT3     COMMENT4     COMMENT5     COMMENT6     BLANK7     Include the game header8     Include the console management header9     BLANK10    COMMENT11    COMMENT12    COMMENT13    COMMENTFIND TRAP NAME14    tr_name returns a character pointer15    Defines tr_name with one argument16    Argument 1 is an integer enum17    BLOCK START - tr_name, returns a string of the trap name18    SWITCH on trap type19    BLOCK START - switch on trap type20    CASE Trapdoor21    Return trap message string22    CASE beartrap23    Return trap message string24    CASE sleeping gas25    Return trap message string26    CASE arrow trap27    Return trap message string28    CASE teleport trap29    Return trap message string30    CASE dart trap31    Return trap message string32    BLOCK END - switch on trap type33    Send a message about the trap to the status bar (including typo! :D)34    Return nothing (fail)35    BLOCK END - tr_name36    BLANK37    COMMENT38    COMMENT39    COMMENT40    COMMENTUPDATE SCREEN41    Defines look with one argument42    Argument 1 is a flag to trigger wakeup of monsters on update43    BLOCK START - look, updates the screen...forced recalculate and redraw44    Declare local position integers45    Declare charcaters46    Declare an integer index47    Declare object pointers48    Declare room pointer49    Declare target coordinates50    Declare a counter for passages51    Declare flags and pointer52    Declare other temporary integers53    BLANK54    Set the room pointer to the player's current room (global var)55    Get the map array index of the player's position56    Get the map's position flags using the index57    Get the map's position character using the index58    COMMENT59    COMMENT60    COMMENT61    BLOCK START - If hero moved...62    If the hero isn't blind...63    Loop through the 3 columns, left/mid/right, around the prev position64    Loop through the 3 rows around the player's old position65    If current position also matches the new position of the player...66    Skip this iteration - nothing to update67    Move the cursor to the current position68    Check the the character at this position69    If the character is the dloor70    If the old room's flags included darkness71    Then make this space a blank (can't see it)72    Otherwise...73    Room isn't dark but get the flags anyway74    COMMENT75    COMMENT76    COMMENT77    COMMENT78    COMMENT79    If the flags of the position is a maze, or is an empty passage room...80    and isn't stairs...81    and the passage number matches the player's current...82    Add the passage character to the space83    End check for maze/passage drawing84    End loop for player row85    End loop for player column86    Update the old position to the new position87    Update the old room pointer to the new room pointer88    BLOCK END - If hero moved89    Set target y position to the row below the hero90    Set target x position to the column to the right of the player91    Set source x position to the column to the right of the player92    Set source y position to the row above the player93    Check if the character will stop for doors and is in motion94    Grab the current sum of the player's coordinates95    Grab the current difference of the player's coordinates96    End check for door-stopping and motion97    Loop from source to target around player (upper left to lower right)98    Loop from source to target around player (upper left to lower right)99    If the row position is outside the map...100   Skip this iteration101   If the player isn't blind...102   If we're on the player's current position103   Skip this iteration104   If the player is blind and the square isn't the player's position105   Skip this iteration106   BLANK107   Get the index value of the current iteration position for the map array108   COMMENT109   COMMENT110   COMMENT111   COMMENT112   Get the position's flags113   Get the position's character114   COMMENT115   COMMENT116   COMMENT117   Make sure the position isn't a door (we don't want to change doors)118   COMMENT119   COMMENT120   COMMENT121   If the hero and space are in room types...122   COMMENT123   COMMENT124   COMMENT125   And the both types aren't mazes...126   Skip this iteration127   End check for different passage rooms128   COMMENT129   COMMENT130   COMMENT131   If the player and the target position are different passages...132   Skip this iteration. (We only want to update contiguous squares)133   BLANK134   Check if there is a monster on the target position...135   If the player sees the monster and it's inivisble then...136   If the player is in motion 137   Stop running138   Skip to next iteration139   Otherwise there is a monster but the player doesn't see it140   If the input wakeup argument is true...141   Then wake up the monster at that position142   If the monster's old character space was set to blank...143   And the room is visible to the player (not dark or blind)..144   Set the monster's old character to the level data145   If the player sees the monster then...146   The monster's buffered character should equal the true map character147   End check for visible monsters148   BLANK149   If the character isn't a floor character but we are in a passage/maze...150   COMMENT151   COMMENT152   COMMENT153   COMMENT154   Make sure the character isn't armor item (As the comment says...)155   Invert the colors of the item to make it stand out in the dark156   BLANK157   Move the cursor to the current position158   Print the character that we've calculated for that space159   Remove any inverse color printing that may have been enabled160   BLANK161   If the player is in run mode, in motion, and capable of auto-stopping...162   BLOCK START - SWITCH on running direction163   CASE If the player is running left...164   If we're currently updating the column to the right of the player...165   Then skip this iteration (no need to update that side)166   CASE If the player is running down...167   If we're currently updating the row above the player...168   Then skip this iteration (no need to update that side)169   CASE If the player is running up...170   If we're currently updating the row below the player...171   Then skip this iteration (no need to update that side)172   CASE If the player is running right...173   If we're currently updating the column to the left of the player...174   Then skip this iteration (no need to update that side)175   CASE If the player is running up and left...176   If we're currently updating a square below or right of the player...177   Then skip this iteration (no need to update that side)178   CASE If the player is running up and right...179   And we're currently updating any square below or to the left180   Then skip this iteration (no need to update that side)181   CASE If the player is running down and left...182   And we're currently updating any square above or right..183   Then skip this iteration (no need to update that side)184   CASE If the player is running down and right...185   And we're currently updating any square above or left...186   Then skip this iteration (no need to update that side)187   BLOCK END - Switch on running direction188   BLOCK START - Switch on the character displayed189   CASE character is a door190   If the player is on the door...191   Then stop running192   End character check193   CASE character is a passage194   If the hero is in a passage195   Increment the local passage counter196   End character check197   CASE character is a floor (fallthrough)198   CASE character is a vertical wall (fallthrough)199   CASE character is a horizontal wall (fallthrough)200   CASE character is an upper-left corner wall (fallthrough)201   CASE character is an upper-right corner wall (fallthrough)202   CASE character is an lower-left corner wall (fallthrough)203   CASE character is an lower-right corner wall (fallthrough)204   CASE character is a space205   Nothing else to do with any of the above, break206   In all other cases (monsters, interesting items...)207   Stop running208   Break from character check209   BLOCK END - Switch on character displayed210   End check for player running changes211   End inner/outer loop for checking squares212   If any passages were encountered..213   Stop the player from running214   Move the player to the chosen coordinates215   If the player is in a passage, or was trapped...216   Or the player is in a maze...217   Invert the color scheme (passages/mazes are difficult to see)218   Finally...draw the player219   End inverted color scheme220   If the player was trapped...221   Make the computer beep! BEEEEEEP222   Clear the trapped flag until the next round of updates223   End check for trapped player224   BLOCK END - look225   BLANK226   COMMENT227   COMMENT228   COMMENT229   COMMENTFIND OBJECT AT POSITION230   find_obj returns a pointer to an object231   Defines find_obj with two arguments232   Arguments are x and y positions on the map233   BLOCK START - find_obj, returns a pointer to an object at input position234   Declare a local pointer to an object235   BLANK236   Loop through all objects on the map237   If the current object matches the input coordinates...238   Return that object239   Check if debug mode is enabled (it's not)240   Output the find to the debug log241   Return nothing242   Otherwise nothing else happens243   COMMENT244   End check for debug mode245   BLOCK START - find_obj246   BLANK247   COMMENT248   COMMENT249   COMMENT250   COMMENTEATING251   Defines eat with no arguments252   BLOCK START - eat, player eats food from pack253   Declare a pointer to an object254   BLANK255   Check inventory and if the player doesn't have any food to eat...256   Return...can't eat257   If the player chose an object to eat that isn't food258   BLOCK START - Trying to eat non-food259   Send a bad message to the player260   End function261   BLOCK END - Trying to eat non-food262   Decrement the inventory size counter263   If the inventory object no longer has a count (stack is empty)264   BLOCK START - Remove object stack from inventory265   Remove the object from inventory266   Free memory for the object267   BLOCK END - Remove object stack from inventory268   Check if the player's food value is negative269   Set the food to zero270   If the player's stomach is close to full..(within 20 units)271   Pass between 2 and 6 turns272   Add food to the player's stomach and check if it's greater than max273   If so...cap the hunger level at max274   Player is no longer hungry275   ***If the player chose to eat his weapon***276   Then remove the weapon (can this happen if weapon wasnt already food?)277   If the player chose to eat unique food...278   Send a good message..279   Otherwise...280   If we roll for a 30% chance..281   BLOCK START - Beneficial food282   Add some experience to the player283   Send message that the food tasted bad...because it's beneficial!284   Check player experience level285   BLOCK END - Beneficial food286   Otherwise...287   Just print a regular message288   If the player ate so much that they can't move289   Print that the player fell asleep290   BLOCK END - eat291   BLANK292   COMMENT293   COMMENT294   COMMENT295   COMMENT296   COMMENTCHANGE STRENGTH297   Defines chg_str with one argument298   Argument 1 is the amount to change strength299   BLOCK START - chg_str, changes player strength by an input amount300   Declare a strength variable301   BLANK302   If the input amount is zero...303   Return, nothing to do304   Otherwise add the strength change to the player's base stats305   Grab the changed amount306   If the player's left ring adds strength...307   Add that bonus to the total strength308   If the player's right ring adds strength...309   Add that bonus to the total strength310   If the new strength amount is larger than the maximum allowable...311   Up the maximum amount to the new calculate amount312   BLOCK END - chg_str313   BLANK314   COMMENT315   COMMENT316   COMMENT317   COMMENTADD STRENGTH318   Defines add_str with two arguments319   Argument 1 is a pointer to the strength value320   Argument 2 is the amount to change321   BLOCK START - add_str, adds to the player's strength322   Apply strength change and if the result is less than 3...323   Floor it at 3324   If the input strength amount is greater than 31325   Cap it at 31326   BLOCK END - add_str327   BLANK328   COMMENT329   COMMENT330   COMMENT331   COMMENTHASTE EFFECT332   Defines add_haste with one agument333   Argument 1 is a flag set if the player used a haste potion334   BLOCK START - add_haste335   If the player has the haste effect applied...(bad if you double haste)336   BLOCK START - double haste337   Player skips up to 8 turns338   Player is no longer running339   Undo haste timer340   Player is no longer hasted341   Send message to player that they overdid it342   Return false, player is not hasted343   BLOCK END - double haste344   Otherwise this is a valid haste attempt345   BLOCK START - regular haste346   Add the haste flag347   If the player drank a potion348   Set up a timer to wear off between 10 and 13 turns349   Return true, player is now hasted350   BLOCK END - regular haste351   BLOCK END - add_haste352   BLANK353   COMMENT354   COMMENT355   COMMENT356   COMMENTAGGRO ALL MONSTERS357   Defines aggravate with no arguments358   BLOCK START - aggravate, wakes up all monsters359   Declare a pointer to an object360   BLANK361   Loop through the list of monsters362   Let them loose!363   BLOCK END - aggravate364   BLANK365   COMMENT366   COMMENT367   COMMENT368   COMMENT369   COMMENTMODIFIES STRINGS FOR VOWELS370   vowelstr returns a pointer to a string371   Defines vowelstr with one argument372   Argument 1 is an input string pointer373   BLOCK START - vowelstr, Converts 'a'->'an' when input starts with vowel374   SWITCH on the input character375   BLOCK START - Switchon the input character376   CASE a: (fallthrough)377   CASE e: (fallthrough)378   CASE i: (fallthrough)379   CASE o: (fallthrough)380   CASE u: (fallthrough)381   Return 'n' (to be added to a previous 'a')382   Otherwise..383   Return blank (also to be added to a previous 'a')384   BLOCK START - Switch on input character385   BLOCK END - vowelstr386   BLANK387   COMMENT388   COMMENT389   COMMENT390   COMMENTCHECK IF OBJECT IS WORN BY PLAYER391   Defines is_current with one argument392   Argument 1 is a pointer to an object393   BLOCK START - is_current, returns true if input object is in use394   If the input object doesn't exist...395   Return false - nothing to point to396   If the input object is the current armor, weapon, left ring...397   ...or the right ring...398   Send a message that the object is already in use399   Return true400   Otherwise the object isn't worn..401   Return false402   BLOCK END - is_current403   BLANK404   COMMENT405   COMMENT406   COMMENT407   COMMENT408   COMMENTQUERY PLAYER FOR MOVEMENT DIRECTION409   Defines get_dir with no arguments410   BLOCK START - get_dir, gets a direction and returns success/fail411   Declare a local string for the player input prompt412   Declare a success/fail flag413   Declare an input character variable414   BLANK415   If the global repeat flag is set then we already have a valid input416   Return true without checking417   Send a message to the player requesting a direction418   Loop while there is no input419   Check if the input character is escape420   Send a blank message to flush the log421   Return false to escape the input422   End loop block423   Repeat loop while there is no input424   Flush the message buffer425   If the player is confused and game rolls a 20% chance that...426   Begin loop to get a random direction427   Get a random x offset428   Get a random y offset429   Repeat loop until there is at least some offset430   Return true - a movement direction was registered431   BLOCK END - get_dir432   BLANKREAD PLAYER INPUT FOR DIRECTION433   Defines find_dir with two arguments434   Argument 1 is a character435   Argument 2 is a coordinate struct (x,y pair)436   BLOCK START - find_dir437   Declare a flag asserted when there is valid input438   BLANK439   Set the input flag to true440   SWITCH on the input character441   CASE character is an H -> set input struct to left offset442   CASE character is an J -> set input struct to down offset443   CASE character is an K -> set input struct to up offset444   CASE character is an L -> set input struct to right offset445   CASE character is an Y -> set input struct to up-left offset446   CASE character is an U -> set input struct to up-right offset447   CASE character is an B -> set input struct to down-left offset448   CASE character is an M -> set input struct to down-right offset449   CASE other, set flag to failure. No valid input450   End switch on input character451   Return the flag452   BLOCK END - find_dir453   BLANK454   COMMENT455   COMMENT456   COMMENT457   COMMENTFIND SIGNEDNESS OF INPUT NUMBER458   Defines sign with one argument459   Argument 1 is the integer to check460   BLOCK START - sign, returns -1,0,1 based on sign of number461 462 463 464 465   BLOCK END - sign466   BLANK467   COMMENT468   COMMENT469   COMMENT470   COMMENTRETURN A RANDOM NUMBER WITH 10% OF INPUT NUMBER471   Defines spread with one argument472   Argument 1 is the input integer to base the result around473   BLOCK START - spread, returns a random number within 10% of input474   Calculate a value 90% of the input value and add back a random 20%475   Return that number which should be between 90% and 110% of the input476   BLOCK END - spread477   BLANK478   COMMENT479   COMMENT480   COMMENT481   COMMENTCREATE OBJECT NAME ALIAS482   Defines call_it with two arguments483   Argument 1 is a flag set if the player already knows what the object is484   Argument 2 is a pointer to the string of the player's choice485   BLOCK START - call_it, assigns player input string to an object486   If the player knows about the object but has a guess...487   Remove the guess because the player knows488   Otherwise, if the player doesn't know but hasn't guessed yet489   Send a message to the player for a guess490   Read the player's guess491   If the guess isn't escape492   Copy the guess from the global print buffer to the object's guess493   Send a blank message to the player (flush the log)494   End check for 495   BLOCK END - call_it496   BLANK497   COMMENT498   COMMENT499   COMMENT500   COMMENTMOVEMENT CHECK501   Defines step ok with one argument - an input char from the map502   BLOCK START - step_ok, returns true if player can move on input space503   SWITCH on input character504   BLOCK START - Switch on input character505   CASE: Empty space (fallthrough)506   CASE: vertical wall (fallthrough)507   CASE: horizontal wall (fallthrough)508   CASE: upper-left corner wall (fallthrough)509   CASE: upper-right corner wall (fallthrough)510   CASE: lower-left corner wall (fallthrough)511   CASE: lower-right corner wall (fallthrough)512   Return false in all cases of walls. Players can't IDSPISPOPD through it513   In all other cases...514   Player can walk on to all non-capital (monster) letters515   BLOCK END - Switch on input character516   BLOCK END - step_ok517   BLANK518   COMMENT519   COMMENT520   COMMENT521   COMMENT522   COMMENT523   BLANKCHANGES OBJECT DISPLAY CHARACTER BASED ON QUALITY524   Defines goodch with one argument525   Argument 1 is a pointer to an object526   BLOCK START - goodch, modifies an object display character if its bad527   Assume input character scheme is a magic object528   BLANK529   If the object is cursed...530   Then it is a bad magic object and needs another color scheme531   BLOCK START - SWITCH on object type532   CASE object is armor533   If the armor class is higher than usual (higher is bad)534   Then set the color scheme to bad535   CASE object is weapon536   If either the hit bonus or damage bonus is negative537   Then set the color scheme to bad538   CASE object is scroll539   Switch the type of magic of the scroll540   If it's a sleep scroll541   If it's a create monster scroll542   If it's a scroll to aggro monsters543   Then set the color scheme to bad544   End check for scroll type545   CASE object is potion546   Switch on the type of potion547   If it's a confuse potion...548   If it's a paralyze potion...549   If it's a poison potion...550   If it's a blind potion...551   Then set the color scheme to bad552   End check for potion type553   CASE object is wand/staff554   Switch on the type of wand/staff555   If it's a haste monster wand/staff...556   If it's a teleport to wand/staff557   Then set the color scheme to bad558   End check for wand/staff type559   CASE object is ring560   Switch on the type of ring561   If it's a protect ring...562   If it's a add strength ring...563   If it's a add damage ring...564   If it's a add hit bonus ring...565   But the bonuses are negative....566   Then set the color scheme to bad567   If it's an aggro monster ring...568   If it's a teleport ring...569   Then set the color scheme to bad570   End check for ring type571   BLOCK END - Switch on object type572   Return the character scheme to print573   BLOCK END - goodch574   BLANK575   COMMENT576   COMMENT577   COMMENTDISPLAY GAME HELP578   Defines help with one argument579   Argument 1 is the help screen to display580   BLOCK START - help, displays game help screen581   Check if help flag is enabled (It is!)582   Declare a help counter583   Declare integers for row and column584   Declare a flag used if the output display is full585   Declare a byte to hold user input586   BLANK587   Saves the contents of the console before we clear it all588   Loop while there is help and user hasn't escaped589   BLOCK START - Output help data590   Start at the beginning - screen isn't full yet591   If we're at the beginning of the screen..592   Clear the screen593   COMMENT594   COMMENT595   COMMENT596   Start at the left597   If we're in terse mode...598   BLOCK START - Terse mode location599   The screen is 23 characters wide so our horiz position is count mod 23600   If we're on row 22...601   Then the screen is full602   BLOCK END - Terse mode location603   Otherwise we're not in terse mode...604   BLOCK START - Normal mode location605   If we're not in terse mode then the width is half of count mod 46606   If we're on an odd character...607   Then assume we're at column 40608   If we're at 22, 40 then...609   The screen is full610   BLOCK END - Normal mode location611   BLANK612   Move the cursor to the current position613   BLANK614   Add a charcater from the help screen and increment pointer to next char615   BLANK616   COMMENT617   COMMENT618   COMMENT619   If the help has fully printed or the screen is full...620   BLOCK START - Output state check621   If the help screen is empty - we're done622   Print message for player to continue623   Otherwise there is more to print and sceeen is full. If terse mode...624   Print a short option for continue or escape to exit625   Otherwise we're not terse626   Print a longer message to continue or exit627   Loop while waiting for user input628   Get user input629   Repeat loop if there is no good input630   BLOCK END - Output state check631   Increment the output counter632   BLOCK END - Output help data633   Restore the saved console output634   End check for help mode flag635   BLOCK END - help636   BLANK637   Check for UNIX (nope - we're using DOS)638   BLANKCALCULATES SQUARED MANHATTAN DISTANCE639   Defines DISTANCE with four arguments640   The arguments are the two x,y positions to check641   BLOCK START - DISTANCE, returns squared Manhattan distance642   Declare two integers to hold distance differences643   BLANK644   Calculate the difference between two Xs645   Calculate the difference betwen two Ys646   Return the squared sum of the differences (guarantees positive result)647   BLOCK END - DISTANCE648   BLANKCHECKS IF TWO COORDINATES ARE EQUAL649   Defines _ce with two arugments650   Both arugments are the two coordinate structs to check651   BLOCK START - _ce, returns true if both input coordinates are equal652   Return true if both coordinates match653   BLOCK END - _ce654   BLANKCONVERTS INPUT POSITION TO A COLUMN-MAJOR INDEX 655   Defines INDEX with two arguments - x and y positions656   BLOCK START - INDEX, returns 657   Check if the DEBUG mode flag is set (it's not)658   If the point is off the map and the coder is playing...(dead code)659   Output a debug error. (dead code)660   End check for debug flag661   Return the column major index value662   BLOCK END - INDEX663   BLANKCHECKS IF INPUT POSITION IS OFF THE MAP664   Defines offmap with two arguments, x and y positions to check665   BLOCK START - offmap, returns true if input is off the map666   Return four corner check against the map size667   BLOCK END - offmap668   BLANKGETS CHARACTER AT A POSITION (includes monsters)669   Defines winat with two arguments670   Arguments are the x and y position to check671   BLOCK START - winat, returns character on the map at input position672   Return either the monter's disguise or the tile character673   BLOCK END - winat674   End check for UNIX flag675   BLANK676   COMMENT677   COMMENT678   COMMENT679   COMMENTPLAYER SEARCHING680   Defines search with no arguments681   BLOCK START - search, searches around the player for hidden things682   Declare temporary integers for x and y position683   Declare a flag pointer684   Declare another pair of invariant positions to interate to around player685   BLANK686   If the player is blind...687   Return because he can't see anything to search688   Set the target y to the map position below the player689   Set the target x to the map position right of the player690   Loop from the row above the player to the row below691   Loop from the column to the left of the player to the one to the right692   BLOCK START - Search loop693   If the square we're search is either at the player or off the map...694   Skip to the next iteration695   Get a pointer to the flags of the tile we're searching696   If the tile is fake (has a hidden secret)697   SWITCH on the type of tile698   BLOCK START - Switch on tile type699   CASE: tile is a vertical wall (fallthrough)700   CASE: tile is a horizontal wall (fallthrough)701   CASE: tile is an upper left corner (fallthrough)702   CASE: tile is an upper right corner (fallthrough)703   CASE: tile is a lower left corner (fallthrough)704   CASE: tile is a lower right corner (fallthrough)705   If we roll anything but a 0 on a 5 sided die...706   Then we didn't find anything (80% chance)707   Check if there is a door on the tile.708   Set the flags for the tile to real (secret is now visible)709   Clear all queued commands and running status710   End search711   CASE tile is empty floor712   Roll for a 50% chance that...713   The player finds nothing714   Otherwise the player finds a trap715   Set the tile flags to real716   Clear command queue/running status717   Send a message that the player found something interesting718   Break search cases719   BLOCK END - Switch on tile type720   BLOCK END - Search loop721   BLOCK END - search722   BLANK723   BLANK724   COMMENT725   COMMENT726   COMMENT727   COMMENTGO DOWN A GAME LEVEL (deeper in to the Dungeon of Doom)728   Defines d_level with no arguments729   BLOCK START - d_level, go down a level 730   Check if the floor under the character doesn't have stairs731   Send a message that the player can't go down732   Otherwise there are stairs so..733   Increment the level734   Generate a new level735   End check for stairs736   BLOCK END - d_level737   BLANK738   COMMENT739   COMMENT740   COMMENT741   COMMENTGO UP A GAME LEVEL (back to an earlier level)742   Defines u_level with no arguments743   BLOCK START - u_level. go up a level744   If the floor under the character is the stairs...745   If the player has the amulet of Yendor (ready to beat the game)746   Decrement the game level747   If the level is now 0...748   Player wins! (this function won't continue below749   Generate a new level750   Send a message to the player that they've changed levels751   Otherwise the player doesn't have the amulet so..752   Send message that the player can't go up.753   Otherwise, there are no stairs here at all so...754   Send message that the player is crazy755   BLOCK END - u_level756   BLANK757   COMMENT758   COMMENT759   COMMENT760   COMMENTPLAYER RENAMING OF OBJECTS761   Defines call with no arguments762   BLOCK START - call, allows player to change names of objects763   Declare a pointer to an object764   Delcare pointer to string pointer and another string pointer765   Declare a flag thats true if the player already knows the object766   BLANK767   Have the player choose an object to rename768   COMMENT769   COMMENT770   COMMENT771   If no object was chosen...772   Return from function773   SWITCH on the type of object774   BLOCK START - Switch on object type775   CASE Object is a ring776   Point the guess string array to the ring guess string array777   Set the know flag to the known ring flags778   Check the current guess for the object and if it has a guess already...779   Set it to the guess, otherwise, set it to the randomized name780   CASE Object is a potion781   Point the guess string array to the potion guess string array782   Set the know flag to the known potion flags783   Check the current guess for the object and if it has a guess already...784   Set it to the guess, otherwise, set it to the randomized name785   CASE Object is a scroll786   Point the guess string array to the scroll guess string array787   Set the know flag to the known scroll flags788   Check the current guess for the object and if it has a guess already...789   Set it to the guess, otherwise, set it to the randomized name790   CASE Object is a wand/staff791   Point the guess string array to the wand/staff guess string array792   Set the know flag to the known wand flags793   Check the current guess for the object and if it has a guess already...794   Set it to the guess, otherwise, set it to the randomized name795   CASE all other objects796   Send message that other objects can't be renamed797   Return from renaming798   BLOCK END - Switch on object type799   If the chosen object is already known...800   BLOCK START - Known object801   Warn the player of failure...there's no guessing hre802   End rename function803   BLOCK END - Known object804   Tell the player was the object was called805   Request a new name806   Get the name from the player807   If the player pressed escape...808   Just copy the old name and proceed809   Clear the message buffer810   BLOCK END - call811   BLANK812   COMMENT813   COMMENT814   COMMENTPLAYER DEFINED MACROS815   Defines macro with two arguments816   Argument 1 is the character buffer to hold input characters817   Argument 2 is the size of the buffer818   BLOCK START - do_macro, allows player to define a macro819   Declare a pointer to the global print buffer820   BLANK821   Send message to player showing the previous macro and requesting new one822   Check if the user input was not simply the escape character823   Loop while the buffer still has characters824   If the character is anything except CTRL-F825   Copy it to the macro buffer826   Repeat loop if the buffer still has more data827   Flush status buffer828   Flush keyboard buffer829   BLOCK END - do_macroDEBUG STUFF (dead code)830   BLANK831   Defines me with no arguments832   If ME macro is defined...(it's not)833   BLOCK START - me, returns a global variable834   Return value of global is_me835   BLOCK END - me836   End check for is_me837   BLANK838   BLANK839   If TEST macro is defined...(it's not)840   Defines istest with no arguments841   BLOCK START - istest, is useless842   Return true if fruit is debug843   BLOCK END - istest844   End check for TEST macro845   EOFÿ