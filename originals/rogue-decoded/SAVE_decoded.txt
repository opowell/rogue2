Decoded: Rogue (1980) by Toy, Arnold, WichmanDOS version (1983) by Mel Sibony and Jon LaneSource file: SAVE.CBeginner friendly, line-by-line code walkthrough by MaiZureSAVE.C provides functions to save and restore the gameOriginal code:https://britzl.github.io/roguearchive/Original code with line numbershttp://www.maizure.org/projects/decoded-rogue/SAVE_linenum.txt1     COMMENT2     COMMENT3     COMMENT4     COMMENT5     COMMENT6     BLANK7     COMMENT8     COMMENT9     COMMENT10    COMMENT11    COMMENT12    COMMENT13    BLANK14    Includes the game header15    Includes the console management header16    BLANK17    COMMENT18    COMMENT19    COMMENT20    Imports pointer to the saved game window21    Imports errno for return values22    Imports the bottom of user memory23    Imports the top of user memory24    Imports the screen retrace checking state25    Imports the screen color mode26    BLANK27    Defines a macro for the id string length28    Defines a string to id the save29    BLANK30    Defines a macro for printf to printw (for the ONE case of printf :S)31    COMMENT32    COMMENT33    COMMENT34    COMMENT35    COMMENT36    Defines the sector size...which is unused37    BLANK38    COMMENT39    COMMENT40    COMMENT41    COMMENTSAVE THE GAME42    Defines save_game with no arguments43    BLOCK START - save_game, saves the game44    Check if this is NOT the demo version. Can't save game in the demo45    Declare a return value46    Declare a buffer for the save game name47    BLANK48    Clear the output message buffer49    Set message buffer position to 050    If we're in terse mode51    Print a short message asking for a save game name52    Otherwise we're in long mode53    Print a longer message...54    Including the default save game name55    The return code is the player's input for game name56    If no name was entered57    Use the default name58    Output a blank message59    And set message buffer position to zero60    If the player didn't hit escape (want's to save)61    BLOCK START - Save the game62    Perform save of data segment and if the return value is failure...63    BLOCK START - Failed to save64    If there was no file to delete...65    Output a message suggesting that the drive is out of space66    In any case, output failure message67    Clear save flag68    BLOCK END - Failed to save69    Otherwise success. If there is some value for the return code70    End process with successful save message71    BLOCK END - Save the game72    Otherwise this is the demo73    BLOCK END - save_game74    End check for demo75    COMMENT76    COMMENT77    COMMENT78    COMMENT79    COMMENT80    COMMENT81    COMMENT82    COMMENTSAVE DATA SEGMENT83    Defines save_ds with one argument84    Argument 1 is the name of the save game85    BLOCK START - save_ds, saves the data segment containing game data86    Declare an integer file descriptor87    Declare a character for user input88    BLANK89    Attempt to open the input file name and if it exists...90    BLOCK START - Overwrite save game91    Close the file92    Send a query for permission to overwrite the save game93    Get user answer94    Clear message buffer95    If the user didn't answer yes96    Return failure97    BLOCK END - Overwrite save game98    BLANK99    Attempt to create a file from data at 0ffset 666. If this fails...100   BLOCK START - Cannot create file101   Send failure message102   Return failure103   BLOCK END - Cannot create file104   Set save flag to true105   Message buffer position to zero106   BLANK107   Errno to 1108   If we cannot write the save header and get the correct size value...109   Or if the user segment size writes don't match...110   Or if the heap doesn't match...111   Jump to error on line 120112   COMMENT113   COMMENT114   COMMENT115   Save the current screen state116   Write the screen data to the save file and check size. If it matches...117   Errno is good to go118   Restore the screen119   BLANK120   Label for error and normal exit121   Close the file122   Switch on errno123   BLOCK START - Switch on errno124   If errno is any value other than 0125   Send message about failure126   Return failure to save127   If errno is ok128   Move to the bottom left129   Clear the line130   Move back one line (presumably to exit to prompt at the bottom)131   Return true132   BLOCK END - Switch on errno133   BLOCK END - save_ds134   End check for demo135   COMMENT136   COMMENT137   COMMENT138   COMMENT139   COMMENT140   COMMENT141   COMMENT142   COMMENT143   COMMENT144   COMMENT145   COMMENTRESTORE A SAVED GAME146   Defines restore with one argument147   Argument 1 is the name of the save file148   BLOCK START - restore, loads and continues a saved game149   Check if this is NOT the demo...no loading games in the demo150   Declare integers to check save version151   Declare integers for file descriptor and column width152   Declare two buffers for file name and error153   Declare an error string154   Declare a register set155   Declare counter of bytes156   Declare a buffer for the save ID157   BLANK158   Save the original register pointer159   Initialize the game window160   If we're in black and white mode161   Set the black and white mode162   If we're skipping the screen retrace check163   Match the flags164   Save the old flag165   Copy the default error message to the buffer166   COMMENT167   COMMENT168   COMMENT169   COMMENT170   Save the current revision171   Save the current version172   BLANK173   Make sure we know the drive letter174   BLOCK START - Print message for restart (this appears dead)175   Save the current screen type176   Print message for space bar177   Kill the screen type (some interrupt triggered here?? - check CURSES)178   Wait for the space bar179   Restore te screen type180   Add carriage return181   BLOCK END - Print message for drive restart182   Try to open the file, but if there is an error...183   Quit with error message184   Otherwise...185   Print a game loading message186   Copy the file name to the buffer187   Calculate the file size188   Read in the short file header, compare it, and if it doesn't match...189   Output an error message190   Otherwise success191   BLOCK START - Read in save file data192   If we can properly read in the data segment193   and we can properly read in the heap194   Jump to line 200195   Otherwise fail with error196   BLOCK END - Read in save file data197   Close the save game file 198   Exit the game199   BLANK200   Label after an ok read201   Restore the registers in case they were clobbered202   If the version numbers don't match203   BLOCK START - Version mismatch204   Close the save game file205   Exit the game206   BLOCK END - Version mismatch207   BLANK208   Restore the old column value209   Move to the new heap210   Reinit the data segment211   Close the current screen212   Open with the new screen data213   If the screen sizes between games don't match...214   BLOCK START - screen mismatch215   Close the save game file216   Exit the game217   BLOCK END - screen mismatch218   BLANK219   Get rid of the current screen220   Read in the screen and if the screen data doesn't match...221   BLOCK START - Failed to get old screen222   Close the save game file223   Exit the game224   BLOCK END - Failed to get old screen225   Restore the game screen with the new data226   BLANK227   Everything worked! Close the file228   Match the retrace settings229   Set message buffer position to 0230   Output a welcome back message231   Roll a new random seed232   Delete the save game file233   End check for demo version234   BLOCK END - restore235   EOFÿ