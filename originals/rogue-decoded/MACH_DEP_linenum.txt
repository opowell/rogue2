1 /*2  * Various installation dependent routines3  *4  * mach_dep.c	1.4 (A.I. Design) 12/1/845  */6 7 #include	"rogue.h"8 #include	"curses.h"9 #include	"keypad.h"10 11 #define ULINE() if(is_color) lmagenta();else uline();12 #define TICK_ADDR 0x7013 static int clk_vec[2];14 static int ocb;15 16 17 /*18  * setup:19  *	Get starting setup for all games20  */21 setup()22 {23 	terse = FALSE;24 	maxrow = 23;25 	if (COLS == 40) {26 		maxrow = 22;27 		terse = TRUE;28 	}29 	expert = terse;30 	/*31 	 * Vector CTRL-BREAK to call quit()32 	 */33 	COFF();34 	ocb = set_ctrlb(0);35 }36 37 clock_on()38 {39 	extern int _csval, clock(), (*cls_)(), no_clock();40 	int new_vec[2];41 42 	new_vec[0] = clock;43 	new_vec[1] = _csval;44 	dmain(clk_vec, 2, 0, TICK_ADDR); 45 	dmaout(new_vec, 2, 0, TICK_ADDR);46 	cls_ = no_clock;47 }48 49 no_clock()50 {51 	dmaout(clk_vec, 2, 0, TICK_ADDR);52 }53 54 /*55  * returns a seed for a random number generator56  */57 srand()58 {59 #ifdef DEBUG60 	return ++dnum;61 #else62 	/*63 	 * Get Time64 	 */65 	bdos(0x2C);66 	return(regs->cx + regs->dx);67 #endif68 }69 70 71 /*72  * flush_type:73  *	Flush typeahead for traps, etc.74  */75 flush_type()76 {77 #ifdef CRASH_MACHINE78 	regs->ax = 0xc06;		/* clear keyboard input */79 	regs->dx = 0xff;		/* set input flag */80 	swint(SW_DOS, regs);81 #endif CRASH_MACHINE82 	typeahead = "";83 }84 85 credits()86 {87 	int i;88 	char tname[25];89 90 	cursor(FALSE);91 	clear();92 	if (is_color)93 	    brown();94 	box(0,0,LINES-1,COLS-1);95 	bold();96 	center(2,"ROGUE:  The Adventure Game");97 	ULINE();98 	center(4,"The game of Rogue was designed by:");99 	high();100 	center(6,"Michael Toy and Glenn Wichman");101 	ULINE();102 	center(9,"Various implementations by:");103 	high();104 	center(11,"Ken Arnold, Jon Lane and Michael Toy");105 	ULINE();106 #ifdef INTL107 	center(14,"International Versions by:");108 #else109 	center(14,"Adapted for the IBM PC by:");110 #endif111 	high();112 #ifdef INTL113 	center(16,"Mel Sibony");114 #else115 	center(16,"A.I. Design");116 #endif117 	ULINE();118 	if (is_color)119 	    yellow();120 	center(19,"(C)Copyright 1985");121 	high();122 #ifdef INTL123 	center(20,"AI Design");124 #else125 	center(20,"Epyx Incorporated");126 #endif127     standend();128 	if (is_color)129 	    yellow();130 	center(21,"All Rights Reserved");131 	if (is_color)132 		brown();133 	for(i=1;i<(COLS-1);i++) {134 		move(22,i);135 		putchr(205);136 	}137 	mvaddch(22,0,204);138 	mvaddch(22,COLS-1,185);139 	standend();140 	mvaddstr(23,2,"Rogue's Name? ");141 	is_saved = TRUE;		/*  status line hack  */142 	high();143 	getinfo(tname,23);144 	if (*tname && *tname != ESCAPE) 145 		strcpy(whoami, tname);146 	is_saved = FALSE;147 	blot_out(23,0,24,COLS-1);148 	if (is_color)149 	    brown();150 	mvaddch(22,0,0xc8);151 	mvaddch(22,COLS-1,0xbc);152 	standend();153 }154 155 /*156  * Table for IBM extended key translation157  */158 static struct xlate {159 	byte keycode, keyis;160 } xtab[] = {161 	C_HOME, 'y', C_UP,	'k', C_PGUP,'u', C_LEFT,	'h', C_RIGHT,	'l',162 	C_END,	'b', C_DOWN,'j', C_PGDN,'n', C_INS,		'>', C_DEL,		's',163 	C_F1,	'?', C_F2,	'/', C_F3,	'a', C_F4,	CTRL(R), C_F5,		'c',164 	C_F6,	'D', C_F7,	'i', C_F8,	'^', C_F9,	CTRL(F), C_F10,		'!',165 	ALT_F9,	'F'166 };167 168 /*169  * readchar:170  *	Return the next input character, from the macro or from the keyboard.171  */172 readchar()173 {174 	register struct xlate *x;175 	register byte ch;176 		177     if (*typeahead) {178         SIG2();179         return(*typeahead++);180     }181     /*182      * while there are no characters in the type ahead buffer183      * update the status line at the bottom of the screen184      */185     do186         SIG2();				/* Rogue spends a lot of time here */187     while (no_char());188 	/*189 	 * Now read a character and translate it if it appears in the190 	 * translation table191 	 */192 	for (ch = getch(), x = xtab; x < xtab + (sizeof xtab) / sizeof *xtab; x++)193 		if (ch == x->keycode) {194 			ch = x->keyis;195 			break;196 		}197     if (ch == ESCAPE)198         count = 0;199     return ch;200 }201 202 bdos(fnum, dxval)203 	int fnum, dxval;204 {205 	register struct sw_regs *saveptr;206 207 	regs->ax = fnum << 8;208 	regs->bx = regs->cx = 0;209 	regs->dx = dxval;210 	saveptr = regs;211 	swint(SW_DOS,regs);212 	regs = saveptr;213 	return(0xff & regs->ax);214 }215 216 /*217  *  newmem - memory allocater218  *         - motto: allocate or die trying219  */220 newmem(nbytes,clrflag)221 	unsigned nbytes;222 	int clrflag;223 {224 	register char *newaddr;225 226 	newaddr = sbrk(nbytes);227 	if (newaddr == -1)228 		fatal("No Memory");229 	end_mem = newaddr + nbytes;230 	if ((unsigned)end_mem & 1)231 		end_mem = sbrk(1);232 	return(newaddr);233 }234 235 #define PC	0xff236 #define XT  0xfe237 #define JR  0xfd238 #define AT	0xfc239 240 isjr()241 {242 	static int machine = 0;243 244 	if (machine == 0) {245 		dmain(&machine,1,0xf000,0xfffe);246 		machine &= 0xff;247 	}248 	return machine == JR;249 }250 251 swint(intno, rp)252 int intno;253 struct sw_regs *rp;254 {255 	extern int _dsval;256 257 	rp->ds = rp->es = _dsval;258 	sysint(intno, rp, rp);259 	return rp->ax;260 }261 262 set_ctrlb(state)263 {264 	struct sw_regs rg;265 	int retcode;266 267 	rg.ax = 0x3300;268 	swint(SW_DOS,&rg);269 	retcode = rg.dx &0xFF;270 271 	rg.ax = 0x3300;272 	rg.dx = (state) ? 1 : 0;273 	swint(SW_DOS,&rg);274 275 	return retcode;276 }277 278 unsetup()279 {280 	set_ctrlb(ocb);281 }282 283 one_tick()284 {285 	extern int tick;286 	int otick = tick;287 	int i=0,j=0;288 289 	while(i++)290 		while (j++)291 			if (otick != tick)292 				return;293 			else if (i > 2)294 				_halt();295 }296 ÿ