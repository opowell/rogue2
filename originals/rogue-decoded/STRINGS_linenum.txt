1 2 3 extern char ctp_[];4 5 isalpha(x) {	return  x > 128 ? 0 : (ctp_[(x)+1]&0x03); }6 isupper(x) {	return  x > 128 ? 0 : (ctp_[(x)+1]&0x01); }7 islower(x) {	return  x > 128 ? 0 : (ctp_[(x)+1]&0x02); }8 isdigit(x) {	return  x > 128 ? 0 : (ctp_[(x)+1]&0x04); }9 isspace(x) {	return  x > 128 ? 0 : (ctp_[(x)+1]&0x10); }10 isprint(x) {	return  x > 128 ? 0 : (ctp_[(x)+1]&0xc7); }11 12 toascii(x)13 {14 	return (x&127);15 }16 17 toupper(chr)18 	char chr;19 {20     return(islower(chr)?((chr)-('a'-'A')):(chr));21 }22 23 tolower(chr)24 	char chr;25 {26 	return(isupper(chr)?((chr)+('a'-'A')):(chr));27 }28 29 stccpy(s1,s2,count)30 	char *s1, *s2;31 	int count;32 {33 	while (count-->0 && *s2)34 		*s1++ = *s2++;35 	*s1 = 0;36 	/*37 	 * lets return the address of the end of the string so38 	 * we can use that info if we are going to cat on something else!!39 	 */40 	return (s1);41 }42 43 44 /*45  * redo Lattice token parsing routines46  */47 char *48 stpblk(str)49 	char *str;50 {51 	while (isspace(*str))52 		str++;53 	return(str);54 }55 56 stpbrk(str,brk)57 	char *str,*brk;58 {59 	while(*str && !index(brk,*str))60 		str++;61 	return(*str ? str : 0);62 }63 64 65 /*66  * remove trailing whitespace from the end of a line67  */68 endblk(str)69 	char *str;70 {71     register char *backup;72 73     backup = str + strlen(str);74     while (backup != str && isspace(*(--backup)))75     	*backup = 0;76 	return(str);77 }78 79 /*80  * lcase: convert a string to lower case81  */82 lcase(str)83 	char *str;84 {85 	while ( *str = tolower(*str) )86 		str++;87 }88 ÿ