Decoded: Rogue (1980) by Toy, Arnold, WichmanDOS version (1983) by Mel Sibony and Jon LaneSource file: MOVE.CBeginner friendly, line-by-line code walkthrough by MaiZureMOVE.C defines movement through the level for both players and monstersOriginal code:https://britzl.github.io/roguearchive/Original code with line numbershttp://www.maizure.org/projects/decoded-rogue/MOVE_linenum.txt1     COMMENT2     COMMENT3     COMMENT4     COMMENT5     COMMENT6     BLANK7     Include the game header8     Include the console management header9     BLANK10    COMMENT11    COMMENT12    COMMENT13    BLANK14    Declare a global to hold updated position during movement15    BLANK16    COMMENT17    COMMENT18    COMMENT19    COMMENTACTIVATE PLAYER RUNNING 20    Defines do_run with one argument21    Argument 1 is the direction to run22    BLOCK START - do_run23    Set global player running flag24    Don't process a turn for turning on running25    Get the running direction26    BLOCK END - do_run27    BLANK28    COMMENT29    COMMENT30    COMMENT31    COMMENT32    COMMENTMOVE PLAYER33    Defines do_move with two arguments34    Arguments 1 and 2 are the deltas for x and y (direction)35    BLOCK START - do_move, processes player movement, may initiate events36    Declares a character to hold the floor value37    Declare an integer to hold the flags of a floor position38    BLANK39    Assume this isn't the first movement of a sequence40    If the movement failed...41    Reset failure flag42    Print a failure message43    Go to the next level44    Return45    End of check for bailout46    If the player cannot move due to a trap or other reason...47    Decrement the no movement counter48    Print a message about being trapped49    Return without moving50    End check for being trapped51    COMMENT52    COMMENT53    COMMENT54    If the player is confused then with 20% chance...55    Move the player in a random direction56    Otherwise this is normal player movement57    Label to redo movement58    Set temporary y coordinate to the player's y plus the change in y59    Set temporary x coordinate to the player's x plus the change in x60    End normal player movement case61    BLANK62    COMMENT63    COMMENT64    COMMENT65    COMMENT66    COMMENT67    If the updated position is not on the map68    Jump to line 104 to process hitting the wall69    If there are diagonal boundaries blocking this new position...70    Don't process movement71    End running72    Return without updating73    End check for diagonal boundary74    COMMENT75    COMMENT76    COMMENT77    COMMENT78    If the player is running but this position is the same...79    Stop all movement80    Get the level flags at the new position81    Get the floor character at the new position82    COMMENT83    COMMENT84    COMMENT85    COMMENT86    If the player is at a door and the new character is a floor87    Stop running at the room transition88    If the floor appears to be normal but it's fake...89    Draw a trap at the position90    Set the position to be real now91    End check for trap92    Otherwise, if the player is held but they aren't attacking the fungi...93    Print that the player cannot move94    Return without movement95    End check for flytrap96    BLOCK START - Switch on the type of floor the player is moving to97    CASE blank/unknown position (fallthrough)98    CASE vertical wall (fallthrough)99    CASE horizontal wall (fallthrough)100   CASE upper-left corner wall (fallthrough)101   CASE upper-right corner wall (fallthrough)102   CASE lower-left corner wall (fallthrough)103   CASE lower-right corner wall104   Label for running in to a barrier105   If the player is running through a passage and isn't blind...106   Declare flags for passage state forward checks107   BLANK108   Switch on the player's running direction109   BLOCK START - Switch on player run direction110   CASE running left (fallthrough)111   CASE running right112   Check if the player is below the top line...113   The next position is still in a passage114   Or the next position is a door.. 115   Check if the player is above the bottom row...116   The next position is a passage117   Or the next position is a door118   If either of the checks are different119   Cancelling running120   If b1 is true121   Change player run direction to follow the wall122   Move the player up one space123   Otherwise..124   Change the player to run down125   Move the player down 1 space126   End check for a passage/door127   Player stops moving left or right  128   Jump to retry to continue running129   CASE running down (fallthrough)130   CASE running up131   Check if the player is not on the left edge  132   ...and that the next step is a passage133   Or the next step is a door134   Check if the player isn't on the right edge135   ...and that the next step is a passage136   or the next step is a door137   If any of the checks are different138   End running139   If the player hit a passage or door on the left...140   Change the run direction to left141   Player is heading left142   Otherwise the player hit a passage on the right143   Change the run direction to right144   Player is heading right145   End check for a passage/door146   Move the player 147   Retry movement148   BLOCK END - Switch on player run direction149   End check for passage running150   Cancel all running move movement151   End moevment check152   CASE a door153   Stop player running154   If the player is in a passage...155   Enter the room156   Jump to line 175 to continue movement for door157   CASE a trap158   Process the trap effects159   If the trap was either a trap door or teleport160   Break from movement161   CASE a passage162   Jump to extended movement processing on line 175163   CASE empty floor164   If the floor is fake...165   Process a trap166     Jump to extended movement processing on line 175167   CASE any other floor type168   Stop running169   If this is an upper case floor (monster) or any other monster (hidden)170   Fight!171   Otherwise this is probably an item on the floor172   Cancel running173   If the floor isn't stairs...174   Prepare to take the item175   Label for extra movement processing176   Draw the hero at the new position177   If the player is in a passage but was in a doorway...178   ...or the playe ris now in a maze179   Leave the previous room180   If the player is now in a maze, but wasn't previously  181   End the maze room182   Finish the move - copy the updated coordiantes to the player position183   End check for extended movement184   BLOCK END - Switch on the type of floor the player is moving to185   BLOCK END - do_move186   BLANK187   COMMENT188   COMMENT189   COMMENT190   COMMENT191   COMMENTOPEN DOORS192   Defines door_open with one argument193   Argument 1 is a pointer to a room194   BLOCK START - door_open, opens a door195   Declare iterators196   Declare a pointer to a floor character197   Declare a pointer to an object198   BLANK199   If the player is in a real room and isn't blind (wake up some monsters!)200   Loop through each row in the room...201   Loop through each column in the room...202   Get the character at the checked position203   COMMENT204   If the character is a monster...205   Wake up the monster206   If the character is unknown and the room isn't dark...207   And the player isn't blind...208   Store the floor position in the now awake monsters209   End check for monster210   Redo loop through the room until we've checked it all211   BLOCK END - door_open212   BLANK213   COMMENT214   COMMENT215   COMMENT216   COMMENTTRAP PLAYER217   Defines be_trapped with one argument218   Argument 1 is the coordinates of the trap219   BLOCK START - be_trapped, set off a trap on the player220   Declare a byte for the trap type221   Declare an index for the level data array222   BLANK223   Reset the movement counter and stop running224   Get the index of the position for the level data arrays225   Set the trap type226   Set and store the trap flag bit227   Store that the player is trapped228   BLOCK START - Switch on the type of trap229   CASE trapdoor230   Drop to the next level and print a message about the trap door231   CASE bear trap232   Stop the player for 2 to 3 turns233   Print message for a bear trap234   CASE sleep trap235   Stop the player for 4 to 5 turns236   Remove the player's running flag237   Print message for a sleep trap238   PRint an extended message239   CASE arrow trap240   If the arrow hits the player..241   Remove between 1 and 6 hitpoints242   If the player is out of health243   Print message for death by arrow trap244   Player dies with cause of death as an arrow245   Otherwise player lived246   Print message for an arrow trap hit247   End check for arrow hit248   Otherwise the arrow missed249   Declare a pointer to 250   BLANK251   Create a new object to be an arrow252   Set the object to type weapon253   Set the weapon type to arrow254   Initialize the arrow255   There is only one arrow256   Copy the arrow position to the player's position257   Drop the arrow on the ground258   End check for arrow creation259   Print message for an arrow trap miss260   End check for missed arrow261   CASE teleport trap262   Teleport the player263   Draw the discovered trap on the ground264   COMMENT265   Increment the trap counter266   CASE dart trap267   If a dart trap hits the player...268   Damage player health between 1 and 4 pointers269   If the player's health is gone270   Print message for death by dart trap271   Cause of death is a dart272   End check for death by dart273   If the player isn't wearing a strength sustainment ring...274   Remove 1 point of strength275   Print message for a dart trap hit276   Otherwise the dart missed277   Print message for a dart trap miss278   BLOCK END - Switch on trap type279   Clear keyboard inpu280   Return the trap type281   BLOCK END - be_trapped282   BLANKGO DOWN A LEVEL283   Defines descend with one argument284   Argument 1 is the message for level change285   BLOCK START - descend, changes levels with an output message286   Change game level number287   If there is no message288   Make it a blank space289   Generate a new level290   Print a blank message291   Print the input message292   Roll a save against luck and if it fails...293   Print message for fall damage294   If the player dies after taking 1 to 8 points of damage..295   Kill player with cause of death as a fall296   End check for failed luck save297   BLOCK END - descend298   BLANK299   COMMENT300   COMMENT301   COMMENT302   COMMENTRANDOM MOVEMENT303   Defines rndmove with two arguments304   Argument 1 is a poiter to whoever is doing the movement305   Argument 2 is the resulting movement position306   BLOCK START - rndmove, randomly choose a movement destination307   Declare x and y position offsets308   Declare a floor character byte309   Declare a pointer to an object310   BLANK311   Randomly choose a row around the input object (above, same, or below)312   Randomly choose a column around the input object (left, same, or right)313   COMMENT314   COMMENT315   COMMENT316   COMMENT317   If the random roll was the exact same place...318   Return - do nothing319   If the random position is outside of the level...320   Jump to line 337 for a failed move321   If the player can't move to the position due to failed diagonal checks..322   Jump to line 337 for a failed move323   Otherwise the move may be ok...324   Get the floor character at the new location325   If there is something blocking the way...326   Jump to line 337 for a failed move327   If there is a scroll at the lcoation...328   Loop through all level objects329   If we find the matching scroll object330   Break loop on this object331   If there is a find and it's a scale monster scroll332   Jump to failed move on line 337333   End check for scroll334   End check for valid position335   Return with the updated position336   BLANK337   Label for failed movement attempt  338   Copy the object's original position in to the return value339   Return the original position - don't move340   BLOCK END - rndmove341   EOF