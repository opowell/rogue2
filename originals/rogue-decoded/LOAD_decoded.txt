Decoded: Rogue (1980) by Toy, Arnold, WichmanDOS version (1983) by Mel Sibony and Jon LaneSource file: LOAD.CBeginner friendly, line-by-line code walkthrough by MaiZureLOAD.C loads title screen graphics by directly manipulating video memoryOriginal code:https://britzl.github.io/roguearchive/Original code with line numbershttp://www.maizure.org/projects/decoded-rogue/LOAD_linenum.txt1     COMMENT2     COMMENT3     COMMENT4     COMMENT5     COMMENT6     BLANK7     Include the game header file8     BLANK9     Defines macro for the hardware mode address in BIOS memory BIOS:0x6510    Defines macro for the address of the 6845 Mode control register 11    Defines macro mask for the B&W enable bit in the mode register12    Defines macro for the address of the color selection register13    Defines macro for the background intensity bit of the color register14    Defines macro...not used15    BLANK16    Declare a pointer to a byte17    Initialize variables for the video block size and a file descriptor18    BLANKSHOW THE TITLE PICTURE19    Defines epyx_yuck with no arguments20    BLOCK START - epyx_yuck, show the epyx title logo21    Import the tick counter from DOS.ASM22    Initialize an integer for the current video mode (text)23    Import sbrk to allocate memory later24    BLANK25    If we're in Monochrome mode or there is no graphics file...26    Return to caller - nothing to do27    Allocate memory for graphics but if we fail..28    Keep trying to allocate with progressively smaller blocks until success29    Set video mode to 320x200, 4 color CGA30    Load and display the graphics31    Reset the tick counter32    If we're logging (we're not)33    Loop forever (dead code)34    Repeat loop35    Otherwise, if no logfile36    Loop while there's no use input37    Repeat loop38    If there is input...39    Read the input40    End check for logfile41    Reset video mode back to the original text mode42    Undo memory allocation for graphics43    Reset tick counter to 044    BLOCK END - epyx_yuck45    BLANKINITIALIZES SCREEN FOR GRAPHICS46    Defines src_load with no arguments47    BLOCK START - scr_load, initializes the screen for graphics display48    Declare integers for the palette and background settings49    Declare integers for the video mode and the color bit50    BLANK51    Load the graphics file in to video memory52    BLANK53    Read the palette settings from byte 8012 of the video now in video mem54    Read the background settings from byte 8013 (these are custom formats)55    BLANK56    If the palette setting is above three...57    Then we can enable high intensity58    Initialize burst (bw mode) to 059    SWITCH on the palette settings60    BLOCK START - Switch on palette61    CASE palette setting is 2 (fallthrough)62    CASE palette setting is 563    Set the burst flag to 1 (bw mode)64    CASE palette setting is 0 (fallthrough)65    CASE palette setting is 366    Palette setting is 167    End of check for palette setting68    CASE palette is 1 (fallthrough)69    CASE palette is 470    Set palette to 071    End check for palette setting72    BLOCK END - Switch on palette73    BLANK74    Output the background to 0x3d9 -- first 5 bits matter75    Read the current mode without the BW flag (using file burst setting)76    If we read in the burst bit...77    Assert the black and white mode78    Then send the updated mode back to the BIOS parameter block79    Output the new mode to the video hardware at 0x3d880    BLOCK END - scr_load81    BLANKLOADS GRAPHICS IN TO VIDEO MEMORY82    Define bload with one argument83    Argument one is the segment number we'll offset from for memory access84    BLOCK START - bload, loads the binary data in to video memory85    Initializes the offset to 0 and declares a read counter86    BLANK87    Read 7 bytes from the file...assume good88    Seek past this amount89    Loop while we continue to read..90    Output the bytes read in to the video memory91    Increment the offset and check it's bounds (should never get this far)92    Break if we've read more than video memory allows93    Repeat loop while we have more to read94    BLOCK END - bload95    BLANKGETS THE CURRENT DRIVE LETTER96    Define find_drive with no arguments97    BLOCK START - find_drive, finds the drive using a DOS software interrupt98    Initializes an integer holding the current drive number from offset 0x19      of the BIOS parameter block99    Gets the save game drive letter100   Allocates space for a file name101   BLANK102   If the drive letter is a letter (is valid)...103   BLOCK START - Set drive number104   If the environment variable drive letter is capitalized...105   The drive number is offset from capital A106   Otherwise the drive letter is lower case...107   Offset from lower case a108   BLOCK END - Set drive number109   Set the file name110   Overwrite the file name with the real drive letter111   Check file accessibility?? (This function isn't included in the source)112   Return the drive letter113   BLOCK END - find_drive114   EOFÿ