Decoded: Rogue (1980) by Toy, Arnold, WichmanDOS version (1983) by Mel Sibony and Jon LaneSource file: PROTECT.CBeginner friendly, line-by-line code walkthrough by MaiZurePROTECT.C provides copy protection services for the disk driveOriginal code:https://britzl.github.io/roguearchive/Original code with line numbershttp://www.maizure.org/projects/decoded-rogue/PROTECT_linenum.txt1     COMMENT2     COMMENT3     COMMENT4     BLANK5     Includes the software interrupt header6     BLANK7     Import goodchk as defined in EXTERN.C8     Declare a global integer to count steps9     BLANK10    Define macro for undefined values11    Define macro for dont-care values12    BLANK13    Define a CRC value of 0x1014    BLANK15    Define a preconfigured register setup for reading rom from disk16    AX = 0x206 (Read 6 sectors from disk...)17    BX register 0 means no offset at destination18    CX = 0x2701 (Read from sector 1, track 39)19    DX is set before invoking 20    SI don't care21    DI don't care22    DS don't care23    ES is where we read to (ROM at 0xF800)24    End of rom reading register setup25    BLANK26    Define a preconfigured register setup for reading the disk signature27    AX = 0x201 (Read 1 sector from disk)28    BX doesn't matter29    CX = 0x2707 (Read sector 7 from track 39)30    DX is set later31    SI doesn't matter32    DI doesn't matter33    DS doesn't matter34    ES doesn't matter35    End signature read register setup36    BLANK37    Define a preconfigured register setup for checking signature38    AX = 0x201 (Read 1 sector from disk)39    BX doesn't matter40    CX reads from sector 60 of the hard drive...Was this install specific?41    DX...42    SI...43    DI...44    DS...45    ES don't matter46    End set up for signature check47    BLANKCHECK DRIVE COPY PROTECTION48    Define protect with one argument - the drive letter as integer49    BLOCK START - protect, confirms copy protection50    Declare an iterator and flags51    Declare a register struct52    Declare a sector-sized buffer53    Declare a smaller buffer54    BLANK55    Increment the step counter56    Pull the drive letter (casted to int) in to DX of all registers57    Set the read target for the signatures to the data segment58    Sig1 memory offset should be equal to the small buffer59    Sig2 memory offset should be equal to the sector sized buffer60    BLANK61    Loop up to 7 times on error. (If flags&CF is true, it's an error)62    BLOCK START - Read from ROM63    Use the rom read register set64    Reset the step counter65    Invoke interrupt to read ROM and set flags66    Increment step counter (it will reset if this failed)67    BLOCK END - Read from ROM68    If there was an error...69    BLOCK START - ROM read error check70    Reset the step counter71    Return failure72    BLOCK END - ROM read error check73    ROM read successful, now loop up to 3 times to read signature74    BLOCK START - Read signature 175    Set up registers for siganture 176    Reset step counter77    Invoke read interrupt78    Increment step counter79    BLOCK END - Read signature 180    If there was an error...81    BLOCK START - Signature read error82    Reset step counter83    Return failure84    BLOCK END - Signature read error85    Loop four times to compare signature integrity86    BLOCK START - Verify signature87    Set registers to read signature 288    Reset step counter89    Invoke interrupt and get flags result90    Increment step counter91    Check if read was successful and the expected checksum is in AX92    BLOCK START - success check93    If the first 32 bytes of the buffers match...94    We're good to go95    Reset step counter96    Return success97    BLOCK END - success check98    BLOCK END - Verify signature99    Reset step counter100   BLOCK END - protect101   EOF