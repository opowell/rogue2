1 2 /*3  * Special wizard commands (some of which are also non-wizard commands4  * under strange circumstances)5  *6  * wizard.c	1.4 (AI Design)	12/14/847  */8 9 #include "rogue.h"10 #include "curses.h"11 12 /*13  * whatis:14  *	What a certin object is15  */16 whatis()17 {18     register THING *obj;19 20     if (pack == NULL) {21 		msg("You don't have anything in your pack to identify");22 		return;23     }24 25     for (;;)26 		if ((obj = get_item("identify", 0)) == NULL) {27 			msg("You must identify something");28 			msg(" ");29 			mpos = 0;30 		} else31 		    break;32 33 	    switch (obj->o_type) {34         when SCROLL:35 		    s_know[obj->o_which] = TRUE;36 		    *s_guess[obj->o_which] = NULL;37         when POTION:38 		    p_know[obj->o_which] = TRUE;39 		    *p_guess[obj->o_which] = NULL;40 		when STICK:41 		    ws_know[obj->o_which] = TRUE;42 		    obj->o_flags |= ISKNOW;43 		    *ws_guess[obj->o_which] = NULL;44         when WEAPON:45         case ARMOR:46 		    obj->o_flags |= ISKNOW;47         when RING:48 		    r_know[obj->o_which] = TRUE;49 		    obj->o_flags |= ISKNOW;50 		    *r_guess[obj->o_which] = NULL;51 	    }52 	    /*53 	     * If it is vorpally enchanted, then reveal what type of monster it is54 	     * vorpally enchanted against55 	     */56 	    if (obj->o_enemy)57 			obj->o_flags |= ISREVEAL;58 	    msg(inv_name(obj, FALSE));59 }60 61 #ifdef WIZARD62 /*63  * create_obj:64  *	Wizard command for getting anything he wants65  */66 create_obj()67 {68     THING *obj;69     byte ch, bless;70 71     if ((obj = new_item()) == NULL)72     {73         msg("can't create anything now");74         return;75     }76     msg("type of item: ");77 	switch (readchar()) {78 		when '!': obj->o_type = POTION;79 		when '?': obj->o_type = SCROLL;80 		when '/': obj->o_type = STICK;81 		when '=': obj->o_type = RING;82 		when ')': obj->o_type = WEAPON;83 		when ']': obj->o_type = ARMOR;84 		when ',': obj->o_type = AMULET;85 		otherwise:86 			obj->o_type = FOOD;87 	}88     mpos = 0;89     msg("which %c do you want? (0-f)", obj->o_type);90     obj->o_which = (isdigit((ch = readchar())) ? ch - '0' : ch - 'a' + 10);91     obj->o_group = 0;92     obj->o_count = 1;93     obj->o_damage = obj->o_hurldmg = "0d0";94     mpos = 0;95     if (obj->o_type == WEAPON || obj->o_type == ARMOR)96     {97 	msg("blessing? (+,-,n)");98 	bless = readchar();99 	mpos = 0;100 	if (bless == '-')101 	    obj->o_flags |= ISCURSED;102 	if (obj->o_type == WEAPON)103 	{104 	    init_weapon(obj, obj->o_which);105 	    if (bless == '-')106 		obj->o_hplus -= rnd(3)+1;107 	    if (bless == '+')108 		obj->o_hplus += rnd(3)+1;109 	}110 	else111 	{112 	    obj->o_ac = a_class[obj->o_which];113 	    if (bless == '-')114 		obj->o_ac += rnd(3)+1;115 	    if (bless == '+')116 		obj->o_ac -= rnd(3)+1;117 	}118     }119     else if (obj->o_type == RING)120 	switch (obj->o_which)121 	{122 	    case R_PROTECT:123 	    case R_ADDSTR:124 	    case R_ADDHIT:125 	    case R_ADDDAM:126 		msg("blessing? (+,-,n)");127 		bless = readchar();128 		mpos = 0;129 		if (bless == '-')130 		    obj->o_flags |= ISCURSED;131 		obj->o_ac = (bless == '-' ? -1 : rnd(2) + 1);132 	    when R_AGGR:133 	    case R_TELEPORT:134 		obj->o_flags |= ISCURSED;135 	}136     else if (obj->o_type == STICK)137 	fix_stick(obj);138     else if (obj->o_type == GOLD)139     {140 	msg("how much?");141 	get_num(&obj->o_goldval, stdscr);142     }143     add_pack(obj, FALSE);144 }145 #endif146 147 /*148  * telport:149  *	Bamf the hero someplace else150  */151 teleport()152 {153     register int rm;154     coord c;155 156     mvaddch(hero.y, hero.x, chat(hero.y, hero.x));157     do158     {159 	rm = rnd_room();160 	rnd_pos(&rooms[rm], &c);161     } while (!(step_ok(winat(c.y, c.x))));162     if (&rooms[rm] != proom)163     {164 	leave_room(&hero);165 	bcopy(hero,c);166 	enter_room(&hero);167     }168     else169     {170 	bcopy(hero,c);171 	look(TRUE);172     }173     mvaddch(hero.y, hero.x, PLAYER);174     /*175      * turn off ISHELD in case teleportation was done while fighting176      * a Fungi177      */178     if (on(player, ISHELD)) {179 	player.t_flags &= ~ISHELD;180 	f_restor();181     }182     no_move = 0;183     count = 0;184     running = FALSE;185     flush_type();186     /*187      * Teleportation can be a confusing experience188      * (unless you really are a wizard)189      */190 #ifdef WIZARD191     if (!wizard)192     {193 #endif WIZARD194 	if (on(player, ISHUH))195 	    lengthen(unconfuse, rnd(4)+2);196 	else197 	    fuse(unconfuse, 0, rnd(4)+2);198 	player.t_flags |= ISHUH;199 #ifdef WIZARD200     }201 #endif WIZARD202     return rm;203 }204 205 #ifdef UNIX206 #ifdef WIZARD207 /*208  * passwd:209  *	See if user knows password210  */211 passwd()212 {213     register char *sp, c;214     char buf[MAXSTR], *crypt();215 216     msg("wizard's Password:");217     mpos = 0;218     sp = buf;219     while ((c = getchar()) != '\n' && c != '\r' && c != ESCAPE)220 	if (c == _tty.sg_kill)221 	    sp = buf;222 	else if (c == _tty.sg_erase && sp > buf)223 	    sp--;224 	else225 	    *sp++ = c;226     if (sp == buf)227 	return FALSE;228     *sp = '\0';229     return (strcmp(PASSWD, crypt(buf, "mT")) == 0);230 }231 232 #endif233 #endif234 235 #ifdef WIZARD236 /*237  * show_map:238  *	Print out the map for the wizard239  */240 show_map()241 {242     register int y, x, real;243 244 	wdump(0);245     wclear(hw);246     for (y = 1; y < maxrow; y++)247 	for (x = 0; x < COLS; x++)248 	{249 	    if (!(real = flat(y, x) & F_REAL))250 		standout();251 	    mvaddch(y, x, chat(y, x));252 	    if (!real)253 		standend();254 	}255     show_win(hw, "---More (level map)---");256     wrestor(0);257 }258 259 get_num(place)260 	int *place;261 {262 	char numbuf[12];263 264 	getinfo(numbuf,10);265 	*place = atoi(numbuf);266 	return(*place);267 }268 #endif269 	270 ÿ