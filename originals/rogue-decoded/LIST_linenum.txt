1 /*2  * Functions for dealing with linked lists of goodies3  * Functions with names starting with an "_" have compainion #defines4  * in rogue.h which take the address of the first argument and pass it on.5  *6  * list.c	1.4 (A.I. Design) 12/5/857  */8 9 #include "rogue.h"10 #include "curses.h"11 12 extern THING *_things;13 extern int   *_t_alloc;14 /*15  * detach:16  *	Takes an item out of whatever linked list it might be in17  */18 _detach(list, item)19 register THING **list, *item;20 {21     if (*list == item)22 	*list = next(item);23     if (prev(item) != NULL) item->l_prev->l_next = next(item);24     if (next(item) != NULL) item->l_next->l_prev = prev(item);25     item->l_next = NULL;26     item->l_prev = NULL;27 }28 29 /*30  * _attach:31  *	add an item to the head of a list32  */33 _attach(list, item)34 register THING **list, *item;35 {36     if (*list != NULL)37     {38 	item->l_next = *list;39 	(*list)->l_prev = item;40 	item->l_prev = NULL;41     }42     else43     {44 	item->l_next = NULL;45 	item->l_prev = NULL;46     }47     *list = item;48 }49 50 /*51  * _free_list:52  *	Throw the whole blamed thing away53  */54 _free_list(ptr)55 register THING **ptr;56 {57     register THING *item;58 59     while (*ptr != NULL)60     {61 	item = *ptr;62 	*ptr = next(item);63 	discard(item);64     }65 }66 67 68 /*69  * new_item70  *	Get a new item with a specified size71  */72 THING *73 new_item()74 {75     register THING *item;76 #ifdef DEBUG77     if ((item = (THING *) talloc()) == NULL)78 	    if (me())msg("no more things!");79 	else80 #else81     if ((item = (THING *) talloc()) != NULL)82 #endif DEBUG83              item->l_next = item->l_prev = NULL;84     return item;85 }86 87 /*88  * talloc: simple allocation of a THING89  */90 talloc()91 {92     register int i;93 94     for (i=0;i<MAXITEMS;i++)95     {96     	if (_t_alloc[i] == 0)97     	{98     	    if (++total > maxitems)99     		maxitems = total;100     	    _t_alloc[i]++;101     	    setmem(&_things[i],sizeof(THING),0);102     	    return &_things[i];103     	}104     }105     return NULL;106 }107 108 /*109  * discard:110  *	Free up an item111  */112 discard(item)113 register THING *item;114 {115     register int i;116 117     for (i=0;i<MAXITEMS;i++)118     {119     	if (item == &_things[i])120     	{121     	    --total;122     	    _t_alloc[i] = 0;123     	    return 1;124     	}125     }126     return NULL;127 }128 ÿ