1 /*2  * Routines dealing specifically with rings3  *4  * rings.c		1.4 (AI Design)		12/13/845  */6 7 #include "rogue.h"8 #include "curses.h"9 10 11 /*12  * ring_on:13  *	Put a ring on a hand14  */15 ring_on()16 {17     register THING *obj;18     register int ring = -1;19 20     if ((obj = get_item("put on", RING)) == NULL)21 		goto no_ring;22     /*23      * Make certain that it is somethings that we want to wear24      */25     if (obj->o_type != RING) {26 		msg("you can't put that on your finger");27 		goto no_ring;28     }29 30     /*31      * find out which hand to put it on32      */33     if (is_current(obj))34 		goto no_ring;35 36     if (cur_ring[LEFT] == NULL)37 		ring = LEFT;38     if (cur_ring[RIGHT] == NULL)39 		ring = RIGHT;40     if (cur_ring[LEFT] == NULL && cur_ring[RIGHT] == NULL)41 		if ((ring = gethand()) < 0)42 		    goto no_ring;43     if (ring < 0) {44 		msg("you already have a ring on each hand");45 		goto no_ring;46     }47     cur_ring[ring] = obj;48 49     /*50      * Calculate the effect it has on the poor guy.51      */52     switch (obj->o_which) {53 	case R_ADDSTR:54 	    chg_str(obj->o_ac);55 	    break;56 	case R_SEEINVIS:57 	    invis_on();58 	    break;59 	case R_AGGR:60 	    aggravate();61 	    break;62     }63 64     msg("%swearing %s (%c)", noterse("you are now "), inv_name(obj, TRUE), pack_char(obj));65     return ;66 67 no_ring:68     after = FALSE;69     return;70 }71 72 /*73  * ring_off:74  *	Take off a ring75  */76 ring_off()77 {78     register int ring;79     register THING *obj;80     register char packchar;81 82     if (cur_ring[LEFT] == NULL && cur_ring[RIGHT] == NULL) {83 		msg("you aren't wearing any rings");84 		after = FALSE;85 		return;86     } else if (cur_ring[LEFT] == NULL)87 		ring = RIGHT;88     else if (cur_ring[RIGHT] == NULL)89 		ring = LEFT;90     else91 		if ((ring = gethand()) < 0)92 		    return;93     mpos = 0;94     obj = cur_ring[ring];95     if (obj == NULL) {96 		msg("not wearing such a ring");97 		after = FALSE;98 		return;99     }100     packchar = pack_char(obj);101     if (can_drop(obj))102 		msg("was wearing %s(%c)", inv_name(obj, TRUE), packchar);103 }104 105 /*106  * gethand:107  *	Which hand is the hero interested in?108  */109 gethand()110 {111     register int c;112 113     for (;;) {114 		msg("left hand or right hand? ");115 		if ((c = readchar()) == ESCAPE)  {116 		    after = FALSE;117 		    return -1;118 		}119 		mpos = 0;120 		if (c == 'l' || c == 'L')121 		    return LEFT;122 		else if (c == 'r' || c == 'R')123 		    return RIGHT;124 		msg("please type L or R");125     }126 }127 128 /*129  * ring_eat:130  *	How much food does this ring use up?131  */132 ring_eat(hand)133 register int hand;134 {135     if (cur_ring[hand] == NULL)136 		return 0;137     switch (cur_ring[hand]->o_which) {138 	case R_REGEN:139 	    return 2;140 	case R_SUSTSTR:141 	case R_SUSTARM:142 	case R_PROTECT:143 	case R_ADDSTR:144 	case R_STEALTH:145 	    return 1;146 	case R_SEARCH:147 	    return(rnd(5)==0);148 	case R_ADDHIT:149 	case R_ADDDAM:150 	    return (rnd(3) == 0);151 	case R_DIGEST:152 	    return -rnd(2);153 	case R_SEEINVIS:154 	    return (rnd(5) == 0);155 	default:156 	    return 0;157     }158 }159 160 /*161  * ring_num:162  *	Print ring bonuses163  */164 char *165 ring_num(obj)166 register THING *obj;167 {168     extern char *ring_buf;169 170     if (!(obj->o_flags & ISKNOW))171 		return "";172     switch (obj->o_which) {173 	when R_PROTECT:174 	case R_ADDSTR:175 	case R_ADDDAM:176 	case R_ADDHIT:177 	    ring_buf[0] = ' ';178 	    strcpy(&ring_buf[1], num(obj->o_ac, 0, RING));179 	otherwise:180 	    return "";181     }182     return ring_buf;183 }184 ÿ