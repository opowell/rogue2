1 /*2  * global variable initializaton3  *4  * init.c	1.4 (A.I. Design) 12/14/845  */6 7 #include "rogue.h"8 #include "curses.h"9 10 THING *_things;11 int   *_t_alloc;12 13 char *newmem();14 15 /*16  * init_player:17  *	Roll up the rogue18  */19 init_player()20 {21     register THING *obj;22     bcopy(pstats,max_stats);23     food_left = HUNGERTIME;24     /*25      * initialize things26      */27 	setmem(_things,MAXITEMS*sizeof(THING),0);28 	setmem(_t_alloc,MAXITEMS*sizeof(int),0);29     /*30      * Give the rogue his weaponry.  First a mace.31      */32     obj = new_item();33     obj->o_type = WEAPON;34     obj->o_which = MACE;35     init_weapon(obj, MACE);36     obj->o_hplus = 1;37     obj->o_dplus = 1;38     obj->o_flags |= ISKNOW;39     obj->o_count = 1;40     obj->o_group = 0;41     add_pack(obj, TRUE);42     cur_weapon = obj;43     /*44      * Now a +1 bow45      */46     obj = new_item();47     obj->o_type = WEAPON;48     obj->o_which = BOW;49     init_weapon(obj, BOW);50     obj->o_hplus = 1;51     obj->o_dplus = 0;52     obj->o_count = 1;53     obj->o_group = 0;54     obj->o_flags |= ISKNOW;55     add_pack(obj, TRUE);56     /*57      * Now some arrows58      */59     obj = new_item();60     obj->o_type = WEAPON;61     obj->o_which = ARROW;62     init_weapon(obj, ARROW);63     obj->o_count = rnd(15) + 25;64     obj->o_hplus = obj->o_dplus = 0;65     obj->o_flags |= ISKNOW;66     add_pack(obj, TRUE);67     /*68      * And his suit of armor69      */70     obj = new_item();71     obj->o_type = ARMOR;72     obj->o_which = RING_MAIL;73     obj->o_ac = a_class[RING_MAIL] - 1;74     obj->o_flags |= ISKNOW;75     obj->o_count = 1;76     obj->o_group = 0;77     cur_armor = obj;78     add_pack(obj, TRUE);79     /*80      * Give him some food too81      */82     obj = new_item();83     obj->o_type = FOOD;84     obj->o_count = 1;85     obj->o_which = 0;86     obj->o_group = 0;87     add_pack(obj, TRUE);88 }89 90 /*91  * Contains definitions and functions for dealing with things like92  * potions and scrolls93  */94 95 static char *rainbow[] = {96     "amber",97     "aquamarine",98     "black",99     "blue",100     "brown",101     "clear",102     "crimson",103     "cyan",104     "ecru",105     "gold",106     "green",107     "grey",108     "magenta",109     "orange",110     "pink",111     "plaid",112     "purple",113     "red",114     "silver",115     "tan",116     "tangerine",117     "topaz",118     "turquoise",119     "vermilion",120     "violet",121     "white",122     "yellow"123 };124 125 #define NCOLORS (sizeof rainbow / sizeof (char *))126 127 static char *c_set = "bcdfghjklmnpqrstvwxyz";128 static char *v_set = "aeiou";129 130 typedef struct {131     char	*st_name;132     int		st_value;133 } STONE;134 135 static STONE stones[] = {136     { "agate",		 25},137     { "alexandrite",	 40},138     { "amethyst",	 50},139     { "carnelian",	 40},140     { "diamond",	300},141     { "emerald",	300},142     { "germanium",	225},143     { "granite",	  5},144     { "garnet",		 50},145     { "jade",		150},146     { "kryptonite",	300},147     { "lapis lazuli",	 50},148     { "moonstone",	 50},149     { "obsidian",	 15},150     { "onyx",		 60},151     { "opal",		200},152     { "pearl",		220},153     { "peridot",	 63},154     { "ruby",		350},155     { "sapphire",	285},156     { "stibotantalite",	200},157     { "tiger eye",	 50},158     { "topaz",		 60},159     { "turquoise",	 70},160     { "taaffeite",	300},161     { "zircon",	 	 80}162 };163 164 #define NSTONES (sizeof stones / sizeof (STONE))165 166 static char *wood[] = {167     "avocado wood",168     "balsa",169     "bamboo",170     "banyan",171     "birch",172     "cedar",173     "cherry",174     "cinnibar",175     "cypress",176     "dogwood",177     "driftwood",178     "ebony",179     "elm",180     "eucalyptus",181     "fall",182     "hemlock",183     "holly",184     "ironwood",185     "kukui wood",186     "mahogany",187     "manzanita",188     "maple",189     "oaken",190     "persimmon wood",191     "pecan",192     "pine",193     "poplar",194     "redwood",195     "rosewood",196     "spruce",197     "teak",198     "walnut",199     "zebrawood"200 };201 202 #define NWOOD (sizeof wood / sizeof (char *))203 204 static char *metal[] = {205     "aluminum",206     "beryllium",207     "bone",208     "brass",209     "bronze",210     "copper",211     "electrum",212     "gold",213     "iron",214     "lead",215     "magnesium",216     "mercury",217     "nickel",218     "pewter",219     "platinum",220     "steel",221     "silver",222     "silicon",223     "tin",224     "titanium",225     "tungsten",226     "zinc"227 };228 229 #define NMETAL (sizeof metal / sizeof (char *))230 231 /*232  * init_things233  *	Initialize the probabilities for types of things234  */235 init_things()236 {237     register struct magic_item *mp;238 239     for (mp = &things[1]; mp <= &things[NUMTHINGS-1]; mp++)240 	mp->mi_prob += (mp-1)->mi_prob;241 }242 243 /*244  * init_colors:245  *	Initialize the potion color scheme for this time246  */247 init_colors()248 {249     register int i, j;250     bool used[NCOLORS];251 252     for (i = 0; i < NCOLORS; i++)253 	used[i] = FALSE;254     for (i = 0; i < MAXPOTIONS; i++)255     {256 	do257 	    j = rnd(NCOLORS);258 	while (used[j]);259 	used[j] = TRUE;260 	p_colors[i] = rainbow[j];261 	p_know[i] = FALSE;262 	p_guess[i] = (char *)&_guesses[iguess++];263 	if (i > 0)264 	    p_magic[i].mi_prob += p_magic[i-1].mi_prob;265     }266 }267 268 /*269  * init_names:270  *	Generate the names of the various scrolls271  */272 273 init_names()274 {275      int nsyl;276      register char *cp, *sp;277      int i, nwords;278 279     for (i = 0; i < MAXSCROLLS; i++)280     {281 	cp = prbuf;282 	nwords = rnd(terse?3:4) + 2;283 	while (nwords--)284 	{285 	    nsyl = rnd(2) + 1;286 	    while (nsyl--)287 	    {288 		sp = getsyl();289 		if (&cp[strlen(sp)] > &prbuf[MAXNAME-1])290 		{291 		    nwords = 0;292 		    break;293 		}294 		while (*sp)295 		    *cp++ = *sp++;296 	    }297 	    *cp++ = ' ';298 	}299 	*--cp = '\0';300 	/*301 	 * I'm tired of thinking about this one so just in case .....302 	 */303 	prbuf[MAXNAME] = 0;304 	s_know[i] = FALSE;305 	s_guess[i] = (char *)&_guesses[iguess++];306 	strcpy(&s_names[i], prbuf);307 	if (i > 0)308 	    s_magic[i].mi_prob += s_magic[i-1].mi_prob;309     }310 }311 312 /*313  * getsyl()314  *   -- generate a random sylable315  */316 getsyl()317 {318     static char _tsyl[4];319 320     _tsyl[3] = 0;321     _tsyl[2] = rchr(c_set);322     _tsyl[1] = rchr(v_set);323     _tsyl[0] = rchr(c_set);324     return (_tsyl);325 }326 327 /*328  * rchr()329  *    return random character in given string330  */331 rchr(string)332     char *string;333 {334     return(string[rnd(strlen(string))]);335 }336 337 /*338  * init_stones:339  *	Initialize the ring stone setting scheme for this time340  */341 init_stones()342 {343     register int i, j;344     bool used[NSTONES];345 346     for (i = 0; i < NSTONES; i++)347 	used[i] = FALSE;348     for (i = 0; i < MAXRINGS; i++)349     {	do350 	    j = rnd(NSTONES);351 	while (used[j]);352 	used[j] = TRUE;353 	r_stones[i] = stones[j].st_name;354 	r_know[i] = FALSE;355 	r_guess[i] = (char *)&_guesses[iguess++];356 	if (i > 0)357 	    r_magic[i].mi_prob += r_magic[i-1].mi_prob;358 	r_magic[i].mi_worth += stones[j].st_value;359     }360 }361 362 /*363  * init_materials:364  *	Initialize the construction materials for wands and staffs365  */366 init_materials()367 {368     register int i, j;369     register char *str;370     bool metused[NMETAL], woodused[NWOOD];371 372     for (i = 0; i < NWOOD; i++)373 	woodused[i] = FALSE;374     for (i = 0; i < NMETAL; i++)375 	metused[i] = FALSE;376     for (i = 0; i < MAXSTICKS; i++)377     {378 	for (;;)379 	    if (rnd(2) == 0)380 	    {381 		j = rnd(NMETAL);382 		if (!metused[j])383 		{384 		    ws_type[i] = "wand";385 		    str = metal[j];386 		    metused[j] = TRUE;387 		    break;388 		}389 	    }390 	    else391 	    {392 		j = rnd(NWOOD);393 		if (!woodused[j])394 		{395 		    ws_type[i] = "staff";396 		    str = wood[j];397 		    woodused[j] = TRUE;398 		    break;399 		}400 	    }401 	ws_made[i] = str;402 	ws_know[i] = FALSE;403 	ws_guess[i] = (char *)&_guesses[iguess++];404 	if (i > 0)405 	    ws_magic[i].mi_prob += ws_magic[i-1].mi_prob;406     }407 }408 409 /*410  * Declarations for allocated things411  */412 long *e_levels;		/* Pointer to array of experience level */413 char *tbuf;		/* Temp buffer used in fighting */414 char *msgbuf;		/* Message buffer for msg() */415 char *prbuf;		/* Printing buffer used everywhere */416 char *end_mem;		/* Pointer to end of memory */417 char *startmem;	    /* Pointer to the start of static memory */418 char *end_sb;		/* Pointer to the end of static base */419 char *ring_buf;		/* Buffer used by ring code */420 421 /*422  *  Declarations for data space that must be saved and restored exaxtly423  */424 byte *_level;425 byte *_flags;426 427 /*428  * init_ds()429  *   Allocate things data space430  */431 init_ds(clrflag)432 	int clrflag;433 {434 	register long *ep;435 436     end_sb = _flags = newmem((MAXLINES-3)*MAXCOLS);437     _level = newmem((MAXLINES-3)*MAXCOLS);438     _things = (THING *)newmem(sizeof(THING) * MAXITEMS);439     _t_alloc = (int *)newmem(MAXITEMS*sizeof(int));440 441     startmem = tbuf = newmem(MAXSTR);442     msgbuf = newmem(BUFSIZ);443     prbuf = newmem(MAXSTR);444     ring_buf = newmem(6);445     e_levels = (long *)newmem(20 * sizeof (long));446     for (ep = e_levels+1, *e_levels = 10L; ep < e_levels + 19; ep++)447     	*ep = *(ep-1) << 1;448     *ep = 0L; 449 }450 ÿ