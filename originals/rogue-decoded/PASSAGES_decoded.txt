Decoded: Rogue (1980) by Toy, Arnold, WichmanDOS version (1983) by Mel Sibony and Jon LaneSource file: PASSAGES.CBeginner friendly, line-by-line code walkthrough by MaiZurePASSAGES.C implements scroll usage and the associated effectsOriginal code:https://britzl.github.io/roguearchive/Original code with line numbershttp://www.maizure.org/projects/decoded-rogue/PASSAGES_linenum.txt1     COMMENT2     COMMENT3     COMMENT4     COMMENT5     COMMENT6     BLANK7     Include game header8     Include console management header9     BLANK10    COMMENT11    COMMENT12    COMMENT13    COMMENTDRAW CORRIDOR14    Defines conn with two arguments15    Arguments 1 and 2 are both indicies in to the room pointer array16    BLOCK START - conn, draws a passageway out of a room (connects another)17    Declare pointers to two rooms to connect18    Delcare indicies to the two room arrays19    Declare distances and points20    Declare a direction for connection21    Declare several coordinates22    BLANK23    If room 1 comes before room 224    Point to the first room 25    If the next room is the second room...26    Then we must be digging right27    Otherwise28    We must be digging down (room + 3) 29    Otherwise room 1 comes after room 230    Point the earlier room to room 231    If room 1 is the subsequent room...32    We're connecting to the right33    Otherwise34    We're connecting down35    End check for digging direction36    Point the source room to the earlieroom37    COMMENT38    COMMENT39    COMMENT40    COMMENT41    If we're digging downward...42    The target room is three rooms forward in the data array43    Get pointer to the target room44    We're not digging left or right45    Only downward46    COMMENT47    COMMENT48    COMMENT49    COMMENT50    If we're drawing from a missing or a maze...51    Start from the bottom of the room52    Loop until we find a blank space53    Choose a random column to draw from54    Retry until we find a valid place to draw from55    Otherwise we're drawing from a normal room56    Start at the left...57    And at the top   58    End check for source room and position59    In the target room, target the top60    If the target room is missing or a maze...61    Loop until we find a valid position62    Choose a random column in the missing room63    Retry until a space is found64    Otherwise the target room is normal65    The column is the left side66    The distance is the abs. difference between top and bottom of the rooms67    We're only heading downward68    The passage should turn either left or right based on column difference69    Measure the intermediate turn by comparing rows70    Otherwise, we're digging a passage to the right71    The target room must be the next room in the data array72    Point to the target room73    We're moving to the right74    We're not moving down or up75    If the source room is missing or a maze...76    Set the source column to the right side77    Loop while we search for a source row78    Choose a random row within the room79    Loop until it's valid80    Otherwise this is a normal room so...81    Source is the left side...82    and top83    End check for source room start position84    We'll target the left side of the target room85    If the room is missing or a maze...86    Loop to find a source row87    Choose a random row88    Loop until it's valid89    Otherwise the room is normal so choose the top row90    Calculate the distance between rooms91    Check which way the passage is turning92    Passage turn must be vertical93    Not horizontal94    The turn distance is the difference between rows95    End check for passage connection dimensions96    Check for debug mode97    In all other cases...98    Something really went off the rails (rooms not adjacent)99    End check for debug mode100   Choose a random position between rooms to make the turn101   COMMENT102   COMMENT103   COMMENT104   COMMENT105   If the source room is real..106   Put a door at the source107   Otherwise it's empty108   Draw a passage there109   If the target room is real110   Draw a door at the other end111   Otherwise112   Draw a passage113   COMMENT  114   COMMENT115   COMMENT116   Start the source x117   And the source y118   While there are still spaces to move...119   BLOCK START - The big dig120   COMMENT121   COMMENT122   COMMENT123   Update by delta x (endpoints already have doors/passage)124   Update by delta y125   COMMENT126   COMMENT127   COMMENT128   If we've reached the turn position129   BLOCK START - passage turn130   Loop while there is turn space remaining131   BLOCK START - dig turn132   Draw a passage the current position133   Update by delta x134   Update by delta y135   BLOCK END - dig turn136   BLOCK END - passage turn137   COMMENT138   COMMENT139   COMMENT140   Dig the passage141   Decrement the distance142   BLOCK END - The big dig143   Arrive at the final x144   Arrive at the final y145   If we haven't arrived at the final position146   Move back one x147   And back one y148   Draw the final passage149   End check for final position150   BLOCK END - conn151   BLANK152   COMMENT153   COMMENT154   COMMENT155   COMMENTCREATE ALL PASSAGES156   Defines do_passages with no arguments157   BLOCK START - do_passages, creates all passages on the level158   Declare two iterators159   Declare a room count integer160   Declare a structure for the room connection matrix161   BLOCK START - Room connection matrix162   The first array is a map of the maximum possible connections163   The second array is the actual connection state for the level164   The third variable is a flag if the room has been initialized165   BLOCK END - Room connection matrix166   Room 1 can connect to rooms 2 and 4. Initially none are connected167   Room 2 can connect to rooms 1, 3 and 5. Initially none are connected168   Room 3 can connect to rooms 2 and 6. Initially none are connected169   Room 4 can connect to rooms 1, 5 and 7. Initially none are connected170   Room 5 can connect to rooms 2, 4, 6, and 8. Initially none are connected171   Room 6 can connect to rooms 3, 5 and 9. Initially none are connected172   Room 7 can connect to rooms 4 and 8. Initially none are connected173   Room 8 can connect to rooms 5, 7 and 9. Initially none are connected174   Room 9 can connect to rooms 6 and 8. Initially none are connected175   End of array initialization176   Declare pointers to the room connection matrix177   BLANK178   COMMENT179   COMMENT180   COMMENT181   Loop through all of the rooms in the connection matrix182   BLOCK START - Clear connection matrix183   Loop through all the elements184   Clear everything185   Clear the in-use flag186   BLOCK END - Clear connection matrix187   BLANK188   COMMENT189   COMMENT190   COMMENT191   COMMENT192   Set room count to 1193   Point to a random room194   Set that random room to true195   Loop on all rooms196   BLOCK START - Connect rooms197   COMMENT198   COMMENT199   COMMENT200   Set random basis to zero201   Loop through each room202   If the room can be connected and it's not connected yet, roll a chance..203   To connect the room204   COMMENT205   COMMENT206   COMMENT207   COMMENT208   If j has looped back to 0...209   BLOCK START - Reset room search210   Loop for another room to search from211   Choose a random room...212   That hasn't been added to the graph213   BLOCK END - Reset room search214   COMMENT215   COMMENT216   COMMENT217   COMMENT218   Otherwise, dig a tunnel to make the connection219   BLOCK START - Digging passages220   Set the second room in the graph221   Find the index to the first room222   Find the index to the second room223   Connect both rooms224   Set the connection matrix for room 1225   Set the connection matrix for room 2226   Increment room counter227   BLOCK END - Digging passages228   BLOCK END - Connect rooms229   BLANK230   COMMENT231   COMMENT232   COMMENT233   COMMENT234   Choose a random number of times to add passages235   BLOCK START - Repeat passage add236   Point to a random room237   COMMENT238   COMMENT239   COMMENT240   Initialize 2nd room index to 0241   Loop through all rooms242   If the room is connectable, but the connection hasnt happened, roll...243   And point to the second room244   COMMENT245   COMMENT246   COMMENT247   COMMENT248   If the second room has a connection...249   BLOCK START - Another connection250   Get the index of the first room251   Get the index of the second room252   Connect the rooms253   Set first room connection in the matrix254   Set second room connection in the matrix255   BLOCK END - Another connection256   BLOCK END - Repeat passage add257   Enumerator all passages258   BLOCK END - do_passages259   BLANK260   BLANK261   COMMENT262   COMMENT263   COMMENT264   COMMENT265   COMMENTCREATE DOOR266   Defines door with two arguments267   Argument 1 is a pointer to a room268   Argument 2 is a coordinate269   BLOCK START - door, adds a door and possibly a secret door270   Declare an index for the map data array271   BLANK272   Get the index for the inpu position273   With a random chance (max 20%)...274   BLOCK START - Make secret exit275   Choose position along the horizontal and verical wall...  276   Set the position to fake (secret doorway)277   BLOCK END - Make secret exit278   Otherwise this is a regular doorway279   Set the input position to door280   Increment the number of exits281   Set the exit y position282   Set the exit x position283   BLOCK END - door284   BLANK285   Check for wizard mode286   COMMENT287   COMMENT288   COMMENT289   COMMENTSHOW PASSAGES290   Defines add_pass with no arguments291   BLOCK START - add_pass, draw all the passages on the level292   Declare interator and a character293   BLANK294   Loop through all rows295   Then through all columns296   If the character is a door or a passage297   Add the character to the map298   BLOCK END - add_pass299   End check for wizard mode300   BLANK301   COMMENT302   COMMENT303   COMMENT304   COMMENT305 306 307   BLANKENUMERATE ALL PASSAGES308   Defines passnum with no arguments309   BLOCK START - passnum, assigns numbers to all passages310   Declare a pointer to a room311   Declare an iterator312   BLANK313   Start with passage number 0314   Start with no new passage315   Loop through all possible passage numbers316   Reset the number of exits317   Loop through all of the rooms then..318   Loop through all the exits319   BLOCK START - Enumerate all passages in all rooms  320   Increment the new passage flag321   Begin enumerating the room at the exit point322   BLOCK END - Enumerate all passages in all rooms323   BLOCK END - passnum324   COMMENT325   COMMENT326   COMMENT327   COMMENTENUMERATE A SINGLE PASSAGE328   Defines numpass with two arguments329   Arguments 1 and 2 are map x and y positions330   BLOCK START - numpass, assign passage number to a passage331   Declare a pointer to level flags332   Declare a pointer to a room 333   Declare a pointer to a map character334   BLANK335   If the input position is off the map336   Return nothing337   Get the flags at the input point338   If there is already a passage number assigned339   Return, nothing to do340   If there is already a passage number in use341   Increment to the next passage number342   Reset the passage number in use flag343   End check for passage number in use344   COMMENT345   COMMENT346   COMMENT347   COMMENT348   If there is a door at this position or a fake door..349   Set the room pointer to the passage array of the passage number350   Set the exit number y position351   Set the exit number x position and increment to next exit352   Otherwise this isn't a door, but if it's also not a passage..353   Return, nothing to do354   Set the passage number to the flags (lower nibble of pointer)355   COMMENT356   COMMENT357   COMMENT358   Recursively enumerate the map position below359   Recursively enumerate the map position above360   Recursively enumerate the map position to the right361   Recursively enumerate the map position to the left362   BLOCK END - numpass363   BLANKDIG A SINGLE PASSAGE SQUARE364   Defines psplat with two arguments365   Arguments 1 and 2 are the x and y positions on the level366   BLOCK START - psplat, dig a single square of a passage367   Declare an index to the level data array368   BLANK369   Set the position map characater to passage370   Set the flag to passage371   BLOCK END - psplat372   EOFÿ