1 /*2  * C copy protection routines3  */4 5 #include	"swint.h"6 7 extern int goodchk;8 int no_step;9 10 #define UNDEFINED	011 #define DONTCARE	012 13 #define	CRC		0x1014 15 static struct sw_regs rom_read = {16 	0x206,17 	0,18 	0x2701,19 	UNDEFINED,20 	DONTCARE,21 	DONTCARE,22 	DONTCARE,23 	0xF80024 } ;25 26 static struct sw_regs sig1_read = {27 	0x201,28 	UNDEFINED,29 	0x2707,30 	UNDEFINED,31 	DONTCARE,32 	DONTCARE,33 	DONTCARE,34 	UNDEFINED35 } ;36 37 static struct sw_regs sig2_read = {38 	0x201,39 	UNDEFINED,40 	0x27F1,41 	UNDEFINED,42 	DONTCARE,43 	DONTCARE,44 	DONTCARE,45 	UNDEFINED46 } ;47 48 protect(drive)49 {50 	int i, flags;51 	struct sw_regs rgs;52 	char buf2[512];53 	char buf1[32];54 55 	no_step++;56 	rom_read.dx = sig1_read.dx = sig2_read.dx = drive;57 	sig1_read.es = sig2_read.es = getds();58 	sig1_read.bx = (int)(&buf1[0]);59 	sig2_read.bx = (int)(&buf2[0]);60 61 	for (i=0,flags=CF;i<7 && (flags&CF);i++)62 	{63 		rgs = rom_read;64 		no_step = 0;65 		flags = sysint(SW_DSK,&rgs,&rgs);66 		no_step++;67 	}68 	if (CF&flags)69 	{70 		no_step = 0;71 		return;72 	}73 	for (i=0,flags=CF;i<3 && (flags&CF);i++)74 	{75 		rgs = sig1_read;76 		no_step = 0;77 		flags = sysint(SW_DSK,&rgs,&rgs);78 		no_step++;79 	}80 	if (CF&flags)81 	{82 		no_step = 0;83 		return;84 	}85 	for (i=0;i<4;i++)86 	{87 		rgs = sig2_read;88 		no_step = 0;89 		flags = sysint(SW_DSK,&rgs,&rgs);90 		no_step++;91 		if ((flags&CF) && HI(rgs.ax) == CRC)92 		{93 			if (memcmp(&buf1[0],&buf2[0x8c],32) == 0)94 				goodchk = 0xD0D;95 			no_step = 0;96 			return ;97 		}98 	}99 	no_step = 0;100 }101 ÿ