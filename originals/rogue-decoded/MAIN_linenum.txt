1 /*2  * ###   ###   ###  #   # #####3  * #  # #   # #   # #   # #4  * #  # #   # #   # #   # #5  * ###  #   # #     #   # ###6  * #  # #   # #  ## #   # #7  * #  # #   # #   # #   # #8  * #  #  ###   ###   ###  #####9  *10  * Exploring the Dungeons of Doom11  * Copyright (C) 1981 by Michael Toy, Ken Arnold, and Glenn Wichman12  * main.c	1.4 (A.I. Design) 11/28/8413  * All rights reserved14  * Copyright (C) 1983 by Mel Sibony, Jon Lane (AI Design update for the IBMPC)15  */16 17 #include "rogue.h"18 #include "curses.h"19 20 #define is_key(s) ((*s=='-')||(*s=='/'))21 #define is_char(c1,c2) ((c1==c2)||((c1+'a'-'A')==c2))22 23 int bwflag = FALSE;24 char do_force = FALSE;25 #ifdef LOGFILE26 int log_read, log_write;27 #endif28 29 /*30  * Permanent stack data31  */32 struct sw_regs *regs;33 34 /*35  * main:36  *	The main program, of course37  */38 39 main(argc, argv)40 int argc;41 char **argv;42 {43     register char *curarg, *savfile=0;44 	struct sw_regs _treg;45 	long junk = 0L;46 	int sl;47 48 	regs = &_treg;49 	dmaout(&junk,2,0,4);50 	clock_on();51 	epyx_yuck();52 	init_ds();53 54     setenv(ENVFILE);55 	protect(find_drive());56 	/*57 	 * Parse the screen environment variable.  if the string starts with58 	 * "bw", then we force black and white mode.  If it ends with "fast"59 	 * then we disable retrace checking60 	 */61 	if (strncmp(s_screen, "bw", 2) == 0)62 		bwflag = TRUE;63 	if ((sl = strlen(s_screen)) >= 464 		 && strncmp(&s_screen[sl - 4], "fast", 4) == 0)65 		 	do_force = TRUE;66 	dnum = 0;67 #ifdef PROTECTED68     while (--argc && goodchk == 0xD0D) {69 #else70     while (--argc) {71 #endif72 		curarg = *(++argv);73     	if (*curarg == '-' || *curarg == '/')74     	{75     	    switch(curarg[1])76     	    {77                 case 'R': case 'r':78     	             savfile = s_save;79     	             break;80     	        case 's': case 'S':81                     winit();82                     noscore = TRUE;83                     is_saved = TRUE;84                     score(0,0,0);85                     fatal("");86 					break;87 #ifdef LOGFILE88 				case 'l':89 					log_write = -1;90 					dnum = 100;91 					break;92 				case 'k':93 					log_read = -1;94 					dnum = 100;95 					break;96 #endif LOGFILE97             }98         }99         else if (savfile == 0)100             savfile = curarg;101     }102     if (savfile == 0) {103 		savfile = 0;104     	winit();105     	if (bwflag) 106     	    forcebw();107 		if (no_check == 0)108 			no_check = do_force;109     	credits();110     	if (dnum == 0)111 			dnum = srand();112     	seed = dnum;113 114 115 		init_player();			/* Set up initial player stats */116 		init_things();			/* Set up probabilities of things */117 		init_names();			/* Set up names of scrolls */118 		init_colors();			/* Set up colors of potions */119 		init_stones();			/* Set up stone settings of rings */120 		init_materials();			/* Set up materials of wands */121 		setup();122 		drop_curtain();123 		new_level();			/* Draw current level */124 		/*125 		 * Start up daemons and fuses126 		 */127 		daemon(doctor, 0);128 		fuse(swander, 0, WANDERTIME);129 		daemon(stomach, 0);130 		daemon(runners, 0);131 		msg("Hello %s%s.", whoami, noterse(".  Welcome to the Dungeons of Doom"));132 		raise_curtain();133     }134     playit(savfile);135 }136 137 /*138  * endit:139  *	Exit the program abnormally.140  */141 endit()142 {143     fatal("Ok, if you want to exit that badly, I'll have to allow it\n");144 }145 146 #define RN		(((seed = seed*11109L+13849L) >> 16) & 0xffff)147 /*148  * Random number generator -149  * adapted from the FORTRAN version 150  * in "Software Manual for the Elementary Functions"151  * by W.J. Cody, Jr and William Waite.152  */153 long154 ran()155 {156 	seed *= 125;157 	seed -= (seed/2796203) * 2796203;158 	return seed;159 }160 161 /*162  * rnd:163  *	Pick a very random number.164  */165 rnd(range)166 register int range;167 {168     return range < 1 ? 0 : ((ran() + ran())&0x7fffffffl) % range;169 }170 171 /*172  * roll:173  *	Roll a number of dice174  */175 roll(number, sides)176 register int number, sides;177 {178     register int dtotal = 0;179 180     while (number--)181 	dtotal += rnd(sides)+1;182     return dtotal;183 }184 185 /*186  * playit:187  *	The main loop of the program.  Loop until the game is over,188  *	refreshing things and looking at the proper times.189  */190 playit(sname,bw)191 	char *sname;192     int bw;193 {194     if (sname) {195 		extern int iscuron;196 		int ov, oc;197 198     	restore(sname);199     	if (bwflag)200     		forcebw();201 		if (no_check == 0)202 			no_check = do_force;203     	setup();204     	iscuron = TRUE;205     	cursor(FALSE);206     } else {207 		oldpos.x = hero.x;208 		oldpos.y = hero.y;209 		oldrp = roomin(&hero);210     }211 #ifdef ME212     is_me = (strcmp(ME, whoami) == 0 || strcmp("Mr. Mctesq", whoami) == 0);213 #endif214     while (playing)215 		command();			/* Command execution */216     endit();217 }218 219 /*220  * quit:221  *	Have player make certain, then exit.222  */223 quit()224 {225     int oy, ox;226     register byte answer;227     static qstate = FALSE;228 229     /*230      * if they try to interupt with a control C while in231      * this routine blow them away!232      */233     if (qstate == TRUE)234 		leave();235     qstate = TRUE;236     mpos = 0;237     getyx(eatme,oy, ox);238     move(0,0);239     clrtoeol();240     move(0,0);241     if (!terse)242     	addstr("Do you wish to ");243     str_attr("end your quest now (%Yes/%No) ?");244     look(FALSE);245     answer = readchar();246     if (answer == 'y' || answer == 'Y') {247 #ifdef DEMO248 		demo(1);249 #else250 		clear();251 		move(0,0);252 		printw("You quit with %u gold pieces\n", purse);253 		score(purse, 1, 0);254 		fatal("");255     } else {256 		move(0, 0);257 		clrtoeol();258 		status();259 		move(oy, ox);260 		mpos = 0;261 		count = 0;262 #endif DEMO263     }264     qstate = FALSE;265 }266 267 /*268  * leave:269  *	Leave quickly, but courteously270  */271 leave()272 {273 	look(FALSE);274     move(LINES - 1, 0);275     clrtoeol();276     move(LINES - 2, 0);277     clrtoeol();278     move(LINES - 2, 0);279     fatal("Ok, if you want to leave that badly\n");280 }281 282 /*283  *  fatal: exit with a message284  */285 fatal(msg,arg) 286 	char *msg;287 	int arg;288 {289 	endwin();290 	printw(msg, arg);291 	exit(0);292 }293 ÿ